# C++基础课
# 第一部分：初窥门径

##  第一章 -  入门

欢迎来到C++的世界！C++是一门强大而灵活的编程语言，它塑造了无数应用，从操作系统到游戏引擎，再到科学计算软件。无论你是编程新手，还是想拓展技能树的开发者，学习C++都能为你打开新世界的大门。

### 1.1 为什么C++如此强大？

**C++是最强大的编程语言之一**，它结合了*高效的性能、精细的内存管理和高级抽象能力*。

这意味着我们可以在C++中既进行底层系统编程，如操作系统和驱动程序的开发，又可以开发高层次的应用程序，如游戏引擎和企业级软件。

当然，学习C++也需要付出努力。C++的语法相对复杂，需要你花时间去理解和掌握。你的努力最终会得到回报。

### 1.2 第一个C++程序: Hello World

学习任何编程语言的第一步都是编写一个简单的程序，在屏幕上打印出 "Hello World!"。让我们来一起完成这个C++的入门仪式吧！

```c++
#include <iostream>

int main() {
  std::cout << "Hello World!" << std::endl;
  return 0;
}
```

**代码解释:**

1. `#include <iostream>`:  这行代码引入了 `iostream` 库，它提供了C++的标准输入输出功能。 你可以把它想象成一个工具箱，里面包含了用于输入输出的各种工具。
2. `int main() { ... }`:  这是C++程序的入口点，程序执行时会从这里开始。 `main` 函数的返回值类型是 `int`，代表整数。
3. `std::cout << "Hello World!" << std::endl;`:  这行代码将 "Hello World!" 字符串输出到控制台。 
    *  `std::cout` 代表标准输出流，可以理解为屏幕。
    * `<<` 是输出运算符，将后面的内容输出到 `std::cout`。
    * `"Hello World!"` 是你要输出的字符串。
    * `std::endl` 表示换行，让下一行输出从新的一行开始。
4. `return 0;`:  这行代码表示程序正常结束，并将 0 返回给操作系统。

**编译运行:**

1.  将以上代码保存为 `.cpp` 文件，例如 `hello.cpp`。
2.  使用C++编译器 (例如 g++，Clang) 编译代码： `g++ hello.cpp -o hello`
3.  运行编译后的程序:  `./hello`

恭喜！你已经成功编写并运行了你的第一个C++程序，并在屏幕上看到了 "Hello World!" 。 

这仅仅是一个开始，接下来的学习中，我们将逐步深入C++的世界，探索更多更强大的功能。**保持你的好奇心和求知欲**，让我们一起踏上这段充满挑战的登山路吧。

## 第二章 - C++语法基础

在编写任何程序之前，我们都需要了解如何使用数据，在C++中，数据以不同的**类型**存储，每种类型都有其特定的用途和操作方式。本章将带你认识C++中常用的**基本数据类型**，以及如何使用**变量**来存储和操作这些数据。

### 2.1 基本数据类型

#### 2.1.1 整型 (Integer)

顾名思义，整型用于表示整数，例如 10，25，-100 等。C++提供了多种整型类型以满足不同的需求，它们的区别在于所能表示的数值范围和占用的内存空间。

| 类型名称 |  占用字节数 |  数值范围  |
|---|---|---|
| `short` | 2  | -2^15^ 到 2^15^ - 1 |
|  `int` | 4  | -2^31^ 到 2^31^ - 1 |
|  `long` | 4 或 8 (取决于编译器)  |  -2^N-1^ 到 2^N-1^ - 1 (N 通常是 32 或 64，取决于系统) |
| `long long` | 8  | -2^63^ 到 2^63^ - 1 |

在大多数情况下，使用 `int` 类型就足够了。如果需要表示更大的整数，可以选择 `long` 或 `long long`。

#### 2.1.2 浮点型 (Floating-Point)

浮点型用于表示带有小数部分的数，例如 3.14，-2.718，1.6e+19 等。C++提供了三种浮点型：

| 类型名称 |  占用字节数 |  精度  |
|---|---|---|
| `float` | 4  | 单精度（约6-7位有效数字） |
|  `double` | 8  | 双精度（约15-16位有效数字） |
|  `long double` | 8 或更大 (取决于编译器)  | 扩展精度（通常比 `double` 更高） |

通常情况下，我们推荐使用 `double` 类型，因为它提供了更高的精度。

#### 2.1.3 字符型 (Character)

字符型用于表示单个字符，例如 'A'，'b'，'5'，'?' 等。需要注意的是，字符要用单引号括起来。C++使用 `char` 类型来存储字符，它占用 1 个字节。

#### 2.1.4 布尔型 (Boolean)

布尔型只有两种取值：`true` (真) 和 `false` (假)。布尔型在条件判断和逻辑运算中非常常用。C++使用 `bool` 类型来表示布尔值。

### 2.2 变量和常量

#### 2.2.1 变量 (Variable)

学习了数据类型后，我们需要一个机制来存储和操作这些数据。这就是 **变量** 的作用。可以将变量想象成一个盒子，可以用来存放特定类型的数据。

在C++中，我们需要先声明变量才能使用它。声明变量的语法如下：

```c++
数据类型 变量名;
```

例如，声明一个整型变量 `age`：

```c++
int age;
```

声明一个浮点型变量 `price`：

```c++
double price;
```

声明变量后，我们就可以使用赋值运算符 `=` 为其赋予初始值：

```c++
int age = 20;
double price = 9.99;
```

#### 2.2.2 常量 (Constant)

与变量不同，**常量** 的值在定义后就不能再被修改。我们可以使用关键字 `const` 来定义常量：

```c++
const double PI = 3.1415926;
```

定义常量时必须赋予初始值，并且之后不能再修改它的值。

### 2.3 输入输出

学习了如何定义变量来存储数据后，我们需要了解如何与用户交互，接收用户的输入并将结果展示给用户。在 C++ 中，我们使用 **输入流** (`cin`) 获取用户输入，使用 **输出流** (`cout`) 将数据输出到屏幕。

#### 2.3.1 使用 `cout` 输出数据

在第一节的 "Hello World" 程序中，我们已经见过 `cout` 的使用了。回顾一下这行代码：

```c++
std::cout << "Hello World!" << std::endl;
```

这里，`std::cout` 代表标准输出流，可以理解为程序输出信息的目的地，通常是屏幕。`<<` 是输出运算符，它将右侧的数据输出到 `std::cout`。 `std::endl` 用于输出一个换行符，并将缓冲区的内容刷新到屏幕上。

除了字符串，我们还可以使用 `cout` 输出各种类型的数据，例如：

```c++
int age = 25;
double price = 19.99;

std::cout << "您的年龄是：" << age << std::endl;
std::cout << "商品价格是：" << price << std::endl;
```

这段代码会依次输出以下内容：

```
您的年龄是：25
商品价格是：19.99
```

#### 2.3.2 使用 `cin` 获取用户输入

要获取用户的键盘输入，我们需要使用 `std::cin` 和输入运算符 `>>`。`cin` 代表标准输入流，`>>` 运算符从 `cin` 读取数据并将其存储到右侧的变量中。

例如，我们可以使用以下代码获取用户的姓名和年龄：

```c++
#include <iostream>
#include <string> // 使用 string 需要引入 string 库

int main() {
    std::string name;
    int age;

    std::cout << "请输入您的姓名：";
    std::cin >> name;

    std::cout << "请输入您的年龄：";
    std::cin >> age;

    std::cout << "您好，" << name << "，您今年 " << age << " 岁。" << std::endl;

    return 0;
}
```

在这段代码中，我们首先声明了一个字符串变量 `name` 和一个整型变量 `age`。然后使用 `cin >> name;`  读取用户输入的字符串并存储到 `name` 变量中，使用 `cin >> age;` 读取用户输入的整数并存储到 `age` 变量中。

#### 2.3.3 `using namespace std` 的作用

你可能注意到，在上面的代码中，我们多次使用了 `std::`  前缀。这是因为 `cout`、`cin`、`endl` 等都属于 C++ 标准库中的 `std` 命名空间。为了避免命名冲突，我们需要使用 `std::` 来指定使用的是 `std` 命名空间中的成员。

为了简化代码，我们可以使用 `using namespace std;`  语句将 `std` 命名空间引入到当前作用域中。这样一来，我们就可以直接使用 `cout`、`cin`、`endl` 等，而无需使用 `std::` 前缀了。

例如，我们可以将上面的代码简化为：

```c++
#include <iostream>
#include <string> 

using namespace std; // 引入 std 命名空间

int main() {
    string name;
    int age;

    cout << "请输入您的姓名：";
    cin >> name;

    cout << "请输入您的年龄：";
    cin >> age;

    cout << "您好，" << name << "，您今年 " << age << " 岁。" << endl;

    return 0;
}
```

需要注意的是，`using namespace std;` 语句会将 `std` 命名空间中的所有成员都引入到当前作用域中，这可能会导致命名冲突。因此，建议在实际项目中谨慎使用 `using namespace std;` 语句，可以考虑只引入需要的成员，例如 `using std::cout;`  或 `using std::cin;`。


#### 2.3.4 `endl` 和 `\n` 的区别

在上面的例子中，我们使用了 `std::endl` 来换行。实际上，C++中还有另一种换行方式，就是使用转义字符 `\n`。

`endl` 和 `\n` 的区别在于：

-  `std::endl` 会在输出换行符的同时*刷新输出缓冲区*。这意味着使用 `endl` 会立即将数据输出到屏幕上。
- `\n` 仅仅是插入一个换行符，*不会刷新输出缓冲区*。这意味着使用 `\n` 时，数据可能不会立即输出到屏幕上，而是等到缓冲区满或者程序结束时才会输出。

在大多数情况下，使用 `endl` 和 `\n` 的效果差别不大。但在处理大量数据输出时，使用 `endl` 可能会影响程序的性能。

### 2.4 运算符和表达式

在编程中，我们经常需要对数据进行各种操作，例如加减乘除、比较大小、判断真假等。C++ 提供了丰富的 **运算符** 来完成这些操作。将运算符应用于操作数的过程就称为 **表达式**。

#### 2.4.1 算术运算符

C++ 中的算术运算符用于执行基本的数学运算，下表列出了常用的算术运算符：

| 运算符 | 描述 | 例子 |
|---|---|---|
| `+` | 加法 | `a + b` |
| `-` | 减法 | `a - b` |
| `*` | 乘法 | `a * b` |
| `/` | 除法 | `a / b` |
| `%` | 取模 (求余数) | `a % b` |

**注意:** 除法运算符 `/` 当两个操作数都是整数时，结果也会是整数，例如 `5 / 2` 的结果是 `2`，而不是 `2.5`。如果需要进行浮点数除法，需要确保至少有一个操作数是浮点型。

#### 2.4.2 关系运算符

关系运算符用于比较两个值的大小关系，返回一个布尔值 (`true` 或 `false`)。

| 运算符 | 描述 | 例子 |
|---|---|---|
| `==` | 等于 | `a == b` |
| `!=` | 不等于 | `a != b` |
| `>` | 大于 | `a > b` |
| `<` | 小于 | `a < b` |
| `>=` | 大于等于 | `a >= b` |
| `<=` | 小于等于 | `a <= b` |

#### 2.4.3 逻辑运算符

逻辑运算符用于组合多个布尔表达式，进行逻辑运算。

| 运算符 | 描述 | 例子 |
|---|---|---|
| `&&` | 逻辑与，两个表达式都为真时结果为真 | `a > 0 && b < 10` |
| `\|\|` | 逻辑或，至少有一个表达式为真时结果为真 | `a == 0 || b == 10` |
| `!` | 逻辑非，反转表达式的真假 | `!(a > b)` |

#### 2.4.4 运算符优先级和结合性

多个运算符出现在同一个表达式中时，C++ 语言规定了它们的 **运算顺序**。例如，`a + b * c` 中，先执行乘法 `b * c`，再执行加法 `a + (b * c)`。这是因为乘法运算符 `*` 的 **优先级** 高于加法运算符 `+`。

下表列出了一些常用运算符的优先级，从高到低排列：

1.  括号 `()`
2.  逻辑非 `!`
3.  算术运算符 (`*`, `/`, `%`)
4.  算术运算符 (`+`, `-`)
5.  关系运算符 (`>`, `<`, `>=`, `<=`)
6.  关系运算符 (`==`, `!=`)
7.  逻辑与 `&&`
8.  逻辑或 `\|\|`

如果多个运算符具有相同的优先级，则根据它们的 **结合性** 来决定运算顺序。例如，减法运算符 `-` 是 **左结合** 的，这意味着表达式 `a - b - c` 会按照 `(a - b) - c` 的顺序计算。

**建议:** 为了避免混淆，最好使用括号来明确表达式的运算顺序，即使不使用括号也能得到正确的结果。

#### 2.4.5 简单的算术和逻辑表达式

以下是一些简单的算术和逻辑表达式的例子:

* 算术表达式：
    * `area = width * height;  // 计算矩形的面积`
    * `average = (score1 + score2 + score3) / 3;// 计算平均分` 
* 逻辑表达式：
    * `isAdult = age >= 18; // 判断是否成年`
    * `isPass = score >= 60 && attendance >= 80; // 判断是否及格`

### 2.5 控制结构

程序的执行默认是按照代码的书写顺序，从上到下逐行执行的。但很多时候，我们需要根据不同的条件选择执行不同的代码块，或者重复执行某些操作。这时就需要用到**控制结构**来改变程序的执行流程。

#### 2.5.1 条件语句

条件语句允许我们根据条件的真假来执行不同的代码块。

##### 2.5.1.1 if 语句

`if` 语句是最基本的条件语句，它的语法如下：

```c++
if (条件表达式) {
    // 当条件表达式为真时执行的代码块
}
```

如果 `条件表达式` 的值为真 (`true`)，则执行 `if` 语句块内的代码；否则跳过 `if` 语句块，继续执行后面的代码。

例如，下面的代码判断一个数是否为偶数：

```c++
int num = 10;

if (num % 2 == 0) {
    std::cout << num << " 是偶数" << std::endl;
}
```

##### 2.5.1.2 if-else 语句

`if-else` 语句允许我们在条件为假时执行另一个代码块。语法如下：

```c++
if (条件表达式) {
    // 当条件表达式为真时执行的代码块
} else {
    // 当条件表达式为假时执行的代码块
}
```

例如，下面的代码判断一个数是正数、负数还是零：

```c++
int num = -5;

if (num > 0) {
    std::cout << num << " 是正数" << std::endl;
} else if (num < 0) {
    std::cout << num << " 是负数" << std::endl;
} else {
    std::cout << num << " 是零" << std::endl;
}
```

##### 2.5.1.3 嵌套 if 语句

`if` 语句可以嵌套在另一个 `if` 语句内部，形成多层条件判断。

```c++
int score = 85;

if (score >= 60) {
    std::cout << "及格" << std::endl;
    if (score >= 80) {
        std::cout << "良好" << std::endl;
        if (score >= 90) {
            std::cout << "优秀" << std::endl;
        }
    }
} else {
    std::cout << "不及格" << std::endl;
}
```

##### 2.5.1.4 switch 语句

当需要对一个变量进行多值判断时，可以使用 `switch` 语句来简化代码。

```c++
int day = 3;

switch (day) {
    case 1:
        std::cout << "星期一" << std::endl;
        break;
    case 2:
        std::cout << "星期二" << std::endl;
        break;
    case 3:
        std::cout << "星期三" << std::endl;
        break;
    // ... other cases
    default:
        std::cout << "输入错误" << std::endl;
}
```

`switch` 语句会将表达式 (`day`) 的值与每个 `case` 后面的常量值进行比较。如果匹配成功，则执行对应的代码块。`break` 语句用于跳出 `switch` 语句，防止继续执行后面的 `case` 代码块。`default` 代码块在没有任何 `case` 匹配成功时执行。

#### 2.5.2 循环语句

循环语句允许我们重复执行一段代码，直到满足特定的条件为止。

##### 2.5.2.1 for 循环

`for` 循环适用于循环次数已知的情况。

```c++
for (初始化表达式; 条件表达式; 循环变量更新表达式) {
    // 循环体代码
}
```

- `初始化表达式` 只在循环开始时执行一次。
- `条件表达式` 在每次循环迭代之前都会被求值，如果为真则执行循环体，否则退出循环。
- `循环变量更新表达式` 在每次循环迭代之后执行。

例如，下面的代码打印 1 到 10 的数字：

```c++
for (int i = 1; i <= 10; i++) {
    std::cout << i << " ";
}
```

##### 2.5.2.2 while 循环

`while` 循环适用于循环次数未知，需要根据条件判断是否继续循环的情况。

```c++
while (条件表达式) {
    // 循环体代码
}
```

只要 `条件表达式` 为真，循环就会一直执行下去。

例如，下面的代码计算 1 到 100 的和：

```c++
int i = 1;
int sum = 0;

while (i <= 100) {
    sum += i;
    i++;
}

std::cout << "1 到 100 的和为：" << sum << std::endl;
```

##### 2.5.2.3 do-while 循环

`do-while` 循环与 `while` 循环类似，但它会先执行一次循环体，然后再判断条件。

```c++
do {
    // 循环体代码
} while (条件表达式);
```

即使 `条件表达式` 初始值为假，`do-while` 循环也会至少执行一次循环体。

例如，下面的代码会先打印 "Hello World!"，然后再判断条件：

```c++
int i = 0;

do {
    std::cout << "Hello World!" << std::endl;
    i++;
} while (i < 5); 
```

##### 2.5.2.4 循环的嵌套与控制

循环可以嵌套在其他循环内部，形成多层循环。在循环执行过程中，我们还可以使用 `break` 和 `continue` 语句来更灵活地控制循环流程。

* **`break` 语句:**  可以用来立即跳出 **当前** 循环，继续执行循环之后的代码。
* **`continue` 语句:**  可以跳过当前循环迭代的 **剩余代码**，进入下一轮迭代。

```c++
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break; // 当 i 等于 5 时跳出循环
    }
    std::cout << i << " ";
}

std::cout << std::endl << "循环结束" << std::endl;
```

**输出结果:**

```
1 2 3 4 
循环结束
```

**解释:** 

* 代码会循环打印 1 到 10 的数字。
* 当 `i` 等于 5 时，`if` 条件成立，执行 `break` 语句，跳出 `for` 循环。
* 因此，循环只执行到 `i` 等于 4，输出了 1 2 3 4。


```c++
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) {
        continue; // 如果 i 是偶数，跳过本次循环剩余代码
    }
    std::cout << i << " "; 
}

std::cout << std::endl << "循环结束" << std::endl;
```

**输出结果:**

```
1 3 5 7 9 
循环结束
```

**解释:** 

* 代码会循环打印 1 到 10 的数字。
* 当 `i` 是偶数时，`if` 条件成立，执行 `continue` 语句。
* `continue` 语句会跳过本次循环剩余的 `std::cout << i << " ";` 代码，直接进入下一轮迭代。
* 因此，循环只会打印奇数 1 3 5 7 9。

### 2.6 函数基础

在 C++ 中，函数是构成程序的基本模块之一。它允许我们将代码封装成可重复使用的单元，从而提高代码的可读性、可维护性和可重用性。

#### 2.6.1 函数的定义与调用

##### 2.6.1.1 函数的声明与实现

在使用函数之前，我们需要先进行**声明**，告诉编译器函数的名字、返回类型以及参数类型。函数的声明也称为函数原型。

函数声明的一般形式如下：

```c++
returnType functionName(parameters); 
```

其中：

* `returnType`：表示函数返回值的类型。如果函数没有返回值，则使用 `void`。
* `functionName`：表示函数的名称，需要遵循标识符的命名规则。
* `parameters`：表示函数的参数，包含参数的类型和名称，多个参数之间用 `,` 分隔。

例如，以下代码声明了一个名为 `add` 的函数，它接受两个整数作为参数，并返回它们的和：

```c++
int add(int a, int b);
```

函数的**定义**包含了函数的具体实现细节，也就是函数体内的代码。函数定义的一般形式如下：

```c++
returnType functionName(parameterList) {
    // 函数体
}
```

例如，以下代码定义了上面声明的 `add` 函数：

```c++
int add(int a, int b) {
    int sum = a + b;
    return sum;
}
```

##### 2.6.1.2 函数参数和返回值

函数参数是函数接收外部数据的一种方式。在函数定义时，我们为每个参数指定类型和名称。在函数调用时，实际传递给函数的值称为**实参**，而函数定义中的参数称为**形参**。

C++ 中参数传递的方式主要有两种：值传递和引用传递。

* **值传递**：将实参的值复制一份传递给形参，函数内部对形参的修改不会影响到实参。
* **引用传递**：将实参的内存地址传递给形参，函数内部对形参的修改会直接影响到实参。

函数返回值是函数执行完毕后返回给调用者的结果。函数可以使用 `return` 语句返回一个指定类型的值。

##### 2.6.1.3函数的调用

定义好函数后，我们就可以在程序中使用它了。函数调用的一般形式如下：

```c++
functionName(arguments);
```

其中，`arguments` 是传递给函数的实参列表，多个实参之间用逗号分隔。

例如，以下代码调用了上面定义的 `add` 函数：

```c++
int main() {
    int x = 10;
    int y = 20;
    int z = add(x, y); // 调用 add 函数，并将 x 和 y 的值传递给它
    cout << "z = " << z << endl; // 输出 z 的值，即 30
    return 0;
}
```

#### 2.6.2 函数的作用域和生命周期

##### 2.6.2.1 局部变量与全局变量

在 C++ 中，变量的作用域是指变量在程序中可以被访问的区域。根据作用域的不同，变量可以分为局部变量和全局变量。

* **局部变量**：定义在函数内部的变量，其作用域仅限于该函数内部。
* **全局变量**：定义在所有函数外部的变量，其作用域是整个程序。

例如：

```c++
#include <iostream>

using namespace std;

int global_var = 10; // 全局变量

int main() {
    int local_var = 20; // 局部变量
    cout << "global_var = " << global_var << endl; // 访问全局变量
    cout << "local_var = " << local_var << endl; // 访问局部变量
    return 0;
}
```

##### 2.6.2.2静态变量和动态内存分配

*变量的生命周期是指变量在程序运行过程中存在的时间段*。根据生命周期的不同，变量可以分为静态变量和动态变量。

* **静态变量**：在程序的编译阶段就分配了内存空间，其生命周期贯穿整个程序的运行过程。全局变量和使用 `static` 关键字修饰的局部变量都属于静态变量。
* **动态变量**：在程序运行过程中动态地分配和释放内存空间，其生命周期由程序员控制。

动态内存分配可以使用 `new` 和 `delete` 运算符来实现。

例如：

```c++
#include <iostream>

using namespace std;

int main() {
    // 静态变量
    static int static_var = 10;

    // 动态变量
    int* dynamic_var = new int;
    *dynamic_var = 20;

    cout << "static_var = " << static_var << endl;
    cout << "dynamic_var = " << *dynamic_var << endl;

    // 释放动态内存
    delete dynamic_var;

    return 0;
}
```

在使用动态内存分配时，需要注意及时释放不再使用的内存空间，避免内存泄漏。

## 第三章 - 数组与字符串

在 C++ 中，数组和字符串是用于存储和处理数据集合的重要数据结构。本章将介绍一维数组、多维数组以及字符串的基本概念、操作方法和常见应用场景。

### 3.1 一维数组

#### 数组的定义和初始化

数组是一组**相同数据类型**的元素的**有序集合**，这些元素在内存中连续存储。在 C++ 中，定义数组需要指定数组类型、数组名以及数组大小。

```c++
dataType arrayName[arraySize];
```

其中：

* `dataType` 表示数组元素的数据类型，例如 `int`，`double`，`char` 等等。
* `arrayName` 是数组的名称，需要遵循标识符的命名规则。
* `arraySize` 是一个常量表达式，表示数组中元素的个数。

以下是 C++ 标识符的命名规则：

1. **字符集**: 标识符只能由字母（a-z，A-Z）、数字（0-9）和下划线（_）组成。
2. **首字符**: 标识符的首字符必须是字母或下划线，不能是数字。
3. **大小写敏感**: C++ 标识符是大小写敏感的，例如 `myVar` 和 `myvar` 是不同的标识符。
4. **保留字**: 不能使用 C++ 的保留字作为标识符，例如 `int`, `float`, `if`, `else`, `while` 等。
5. **长度限制**: C++ 标准并未规定标识符的最大长度，但建议标识符的长度不要过长，一般不超过 31 个字符。
6. **命名规范**: 为了提高代码可读性，建议遵循以下命名规范：
   - **变量名和函数名**: 通常使用小写字母开头，单词之间使用下划线或驼峰命名法（例如 `my_variable`，`myVariable`）。
   - **常量名**: 通常使用全部大写字母，单词之间使用下划线（例如 `MY_CONSTANT`）。
   - **类名**: 通常使用大写字母开头，每个单词的首字母大写（例如 `MyClass`）。

例如，以下代码定义了一个名为 `numbers` 的整型数组，该数组可以存储 5 个整数：

```c++
int numbers[5];
```

定义数组后，我们可以使用索引访问数组中的每个元素。数组索引从 0 开始，到 `arraySize - 1` 结束。例如，`numbers[0]` 表示数组 `numbers` 的第一个元素。

在定义数组时，我们可以使用以下几种方式进行初始化：

* **使用初始化列表**：在数组定义时，使用花括号 `{}` 将初始值依次列出。

```c++
int numbers[5] = {1, 2, 3, 4, 5};
```

* **指定部分元素的初始值**：如果初始化列表中的元素个数少于数组大小，则剩余元素将被初始化为 0。

```c++
int numbers[5] = {1, 2, 3}; // numbers[3] 和 numbers[4] 将被初始化为 0
```

* **省略数组大小**：如果在定义数组时使用了初始化列表，并且没有指定数组大小，则编译器会根据初始化列表中的元素个数自动确定数组大小。

```c++
int numbers[] = {1, 2, 3, 4, 5}; // 数组大小为 5
```

#### 数组的遍历与操作

我们可以使用循环结构遍历数组中的所有元素，并对每个元素进行操作。

```c++
int numbers[5] = {1, 2, 3, 4, 5};

// 使用 for 循环遍历数组
for (int i = 0; i < 5; ++i) {
    cout << numbers[i] << " ";
}
// 输出：1 2 3 4 5
```

在循环体内，我们可以对数组元素进行各种操作，例如读取元素的值、修改元素的值、进行算术运算等等。

### 3.2 多维数组

多维数组是指数组的元素本身也是数组。其中，二维数组是最常见的，可以看作是元素排列成矩形表格的数组。

#### 二维数组的定义与初始化

二维数组的定义方式与一维数组类似，只是需要在数组名后使用两个方括号 `[][]` 来指定数组的行数和列数。

```c++
dataType arrayName[rows][cols];
```

其中：

* `rows` 表示二维数组的行数。
* `cols` 表示二维数组的列数。

例如，以下代码定义了一个 3 行 4 列的二维数组：

```c++
int matrix[3][4];
```

二维数组的初始化可以使用嵌套的花括号 `{{}, {}, ...}` 将初始值依次列出，每个花括号代表一行数据。

```c++
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```

#### 多维数组的常见应用

多维数组常用于表示矩阵、表格、图像等数据结构。例如，在图像处理中，可以使用二维数组来存储图像的像素信息。

### 3.3 字符串处理

在 C++ 中，字符串可以使用字符数组或 `string` 类来表示。本节主要介绍 C 风格字符串，即使用字符数组表示的字符串。

#### C 风格字符串（char 数组）

C 风格字符串是存储在字符数组中，并以空字符 `\0` 结尾的字符序列。例如，字符串 "hello" 在内存中存储如下：

```
h e l l o \0
```

定义字符数组时，需要确保数组大小足以容纳字符串的所有字符以及结尾的空字符。

```c++
char str1[6] = "hello";
char str2[] = "world"; // 数组大小自动推导为 6
```

#### 常用字符串操作函数（strlen, strcpy, strcat 等）

C++ 标准库提供了一系列用于操作 C 风格字符串的函数，这些函数声明在头文件 `cstring` 中。

* `strlen(str)`：返回字符串 `str` 的长度，不包括结尾的空字符。
* `strcpy(dest, src)`：将字符串 `src` 复制到字符数组 `dest` 中，包括结尾的空字符。
* `strcat(dest, src)`：将字符串 `src` 连接到字符数组 `dest` 的末尾。
* `strcmp(str1, str2)`：比较字符串 `str1` 和 `str2` 的字典序。如果 `str1` 等于 `str2`，则返回 0；如果 `str1` 小于 `str2`，则返回负数；如果 `str1` 大于 `str2`，则返回正数。

使用这些函数可以方便地进行字符串的长度计算、复制、连接和比较等操作。

```c++
#include <iostream>
#include <cstring>

using namespace std;

int main() {
    char str1[10] = "hello";
    char str2[] = "world";

    cout << "str1 length: " << strlen(str1) << endl; // 输出 5

    strcat(str1, " ");
    strcat(str1, str2);
    cout << "str1: " << str1 << endl; // 输出 hello world

    return 0;
}
```

### 5.4 string

在上面的课程中，我们使用`char`数组来存储和操作字符串，但这种方式存在一些缺陷，例如需要手动管理内存、操作函数有限等。为了更方便地处理字符串，C++ 提供了 `string` 类。

#### 5.4.1 `string` 类的定义和初始化

`string` 类位于 `<string>` 头文件中，使用时需要包含该头文件：

```c++
#include <string>
using namespace std;
```

可以使用多种方式来定义和初始化 `string` 对象：

```c++
string str1; // 定义一个空字符串
string str2 = "Hello"; // 定义并初始化一个字符串
string str3(str2); // 使用另一个字符串初始化
string str4(5, 'a'); // 使用 5 个字符 'a' 初始化
```

#### 5.4.2 `string` 类的常用操作

`string` 类提供了丰富的成员函数来操作字符串，以下是一些常用的操作：

* **获取字符串长度**: `str.length()` 或 `str.size()`
* **访问字符串中的字符**:  `str[index]` (可以使用 `[]` 运算符像数组一样访问字符串中的字符)
* **连接字符串**: `str1 + str2` 或 `str1 += str2`
* **比较字符串**: `str1 == str2`, `str1 != str2`, `str1 < str2` 等
* **查找字符串**: `str.find(substring)` (返回第一次出现的子串的起始位置)
* **替换字符串**: `str.replace(pos, len, new_str)` (将从 `pos` 开始的 `len` 个字符替换为 `new_str`)
* **插入字符串**: `str.insert(pos, new_str)` (在 `pos` 位置插入 `new_str`)
* **删除字符串**: `str.erase(pos, len)` (删除从 `pos` 开始的 `len` 个字符)
* **子字符串**: `str.substr(pos, len)` (返回从 `pos` 开始的 `len` 个字符组成的子串)

以下是一些示例代码：

```c++
#include <iostream>
#include <string>

using namespace std;

int main() {
    string str1 = "Hello";
    string str2 = "World";

    // 获取字符串长度
    cout << "str1.length(): " << str1.length() << endl; // 输出 5

    // 连接字符串
    string str3 = str1 + " " + str2;
    cout << "str3: " << str3 << endl; // 输出 Hello World

    // 查找字符串
    int pos = str3.find("World");
    cout << "pos: " << pos << endl; // 输出 6

    // 替换字符串
    str3.replace(6, 5, "C++");
    cout << "str3: " << str3 << endl; // 输出 Hello C++

    return 0;
}
```

`string` 类提供了一种方便、安全、高效的方式来处理字符串，建议在程序中尽量使用 `string` 类来代替 `char` 数组。


## 第四章 - 指针与引用

**指针是C++中最强大的功能之一**，但也是初学者最难掌握的概念之一。本章将详细介绍指针的基础知识和高级应用，帮助你更好地理解和使用指针。

### 4.1 指针基础

#### 指针的定义和初始化

想象内存是一个拥有连续编号的房间的旅馆，每个房间都能存储数据。*房间的编号就是内存地址*，而指针就是一张记录了某个房间号码的纸条。

指针变量的定义方式是在类型名后面加上星号 `*`：

```c++
dataType *pointerName;
```

例如，`int *ptr;` 定义了一个名为 `ptr` 的指针变量，它可以存储一个整型变量的内存地址。

在使用指针之前，我们需要先初始化它，也就是将一个有效的内存地址赋值给它。常见的初始化方法有：

* **使用取地址运算符 `&` 获取变量的地址**:

```c++
int num = 10;
int *ptr = &num;  // ptr 现在存储了 num 的地址
```

* **将指针初始化为 `nullptr`**:

```c++
int *ptr = nullptr;  // ptr 不指向任何有效的内存地址
```

#### 指针与地址运算符

指针和地址运算符 `&`、`*` 密切相关：

* **取地址运算符 `&`**: 用于获取变量的内存地址。例如，`&num` 返回变量 `num` 的内存地址。
* **解引用运算符 `*`**: 用于访问指针所指向的内存地址处的值。例如，`*ptr` 返回 `ptr` 所指向的内存地址处的值。

以下代码演示了指针和地址运算符的使用：

```c++
#include <iostream>

using namespace std;

int main() {
    int num = 10;
    int *ptr = &num;

    cout << "num 的地址: " << &num << endl;     // 输出 num 的地址
    cout << "ptr 的值: " << ptr << endl;        // 输出 ptr 的值，即 num 的地址
    cout << "*ptr 的值: " << *ptr << endl;      // 输出 ptr 指指向的地址的值，即 10

    return 0;
}
```

输出如下：

```output
num 的地址: 0x7ffeedf6c8c8
ptr 的值: 0x7ffeedf6c8c8
*ptr 的值: 10
```

**注意：**

我们之所以要写 `int *ptr = &num;` 而不是 `int ptr = &num;`，是因为两者的类型不同，含义也不同。

* `int *ptr = &num;`  
   *  `int *ptr` 声明了一个 **指向整型变量的指针** `ptr`。这意味着 `ptr`  里面存储的是一个整型变量的内存地址。
   *  `&num`  获取整型变量 `num` 的内存地址。
   *  `=` 将 `num` 的地址赋值给指针 `ptr`。
   *  总而言之，这行代码的意思是：**创建一个名为 `ptr` 的指针，它指向 `num`  这个整型变量。**

* `int ptr = &num;` 
   *   `int ptr`  声明了一个 **整型变量** `ptr`。这意味着 `ptr`  里面应该存储一个整型数值。
   *   `&num`  获取整型变量 `num` 的内存地址。
   *   `=`  尝试将 `num` 的地址赋值给整型变量 `ptr`。
   *   **这种写法是错误的！**  因为你试图将一个内存地址赋值给一个只能存储整型数值的变量，类型不匹配，编译器会报错。

**简单来说：**

*  `int *ptr` :  声明一个指针，用来存储 **地址**，这个地址指向一个 `int` 类型的变量。
*  `int ptr`:   声明一个整型变量，用来存储 **整型数值**。

### 4.2 指针的高级应用

#### 指针数组和数组指针

* **指针数组**: 是指数组中的每个元素都是指针。例如，`int *ptrArray[5];` 定义了一个包含 5 个整型指针的数组。

* **数组指针**: 是指指向数组的指针。例如，`int (*ptrToArray)[5];` 定义了一个指向包含 5 个整数的数组的指针。

#### 函数指针与回调函数

* **函数指针**:  就像指针可以存储变量的地址一样，函数指针可以存储函数的入口地址。定义函数指针的语法如下：

```c++
returnType (*pointerName)(parameterList);
```

例如，`int (*funcPtr)(int, int);` 定义了一个名为 `funcPtr` 的函数指针，它指向一个接受两个 int 参数并返回 int 值的函数。

* **回调函数**: 回调函数是指通过函数指针调用的函数。回调函数通常用于事件处理、排序算法等场景。

以下代码演示了函数指针和回调函数的使用：

```c++
#include <iostream>

using namespace std;

// 定义一个函数
int add(int a, int b) {
    return a + b;
}

// 定义一个接受函数指针作为参数的函数
int operate(int a, int b, int (*func)(int, int)) {
    return func(a, b);
}

int main() {
    // 定义一个函数指针，并将其指向 add 函数
    int (*funcPtr)(int, int) = add;

    // 使用函数指针调用 add 函数
    int result1 = funcPtr(10, 20);
    cout << "result1: " << result1 << endl; // 输出 30

    // 将函数指针作为参数传递给 operate 函数
    int result2 = operate(10, 20, funcPtr);
    cout << "result2: " << result2 << endl; // 输出 30

    return 0;
}
```

### 4.3 引用

在 C++ 中，引用提供了一种为已有变量创建别名的机制。引用并非创建新的对象，而是为已存在的变量提供了一个新的名称。理解引用，可以帮助我们更方便地操作变量，提高代码的效率和可读性。

#### 引用的定义与使用

引用的声明方式是在类型名后面加上 `&` 符号：

```c++
dataType& referenceName = variableName;
```

其中：

* `dataType` 是被引用变量的数据类型。
* `referenceName` 是引用的名称，需遵循标识符命名规则。
* `variableName` 是被引用的变量名。

例如，以下代码定义了一个名为 `ref` 的整型引用，它引用了变量 `num`：

```c++
int num = 10;
int& ref = num;
```

定义引用 `ref` 后，`ref` 就成为了变量 `num` 的别名。对 `ref` 的任何操作，实际上都是对 `num` 进行操作。

```c++
ref = 20;  // 修改 ref 的值，实际上是修改 num 的值
cout << num << endl;  // 输出 20
cout << ref << endl;  // 也输出 20
```

#### 引用与指针的区别

引用和指针都可以用来间接访问和操作变量，但它们之间存在一些重要的区别：

| 特性 | 引用 | 指针 |
|---|---|---|
| 定义 | 使用 `&` 声明 | 使用 `*` 声明 |
| 初始化 | 必须在定义时初始化 | 可以不初始化，但存在风险 |
| 空值 | 不存在空引用 | 可以为空指针 (`nullptr`) |
| 修改指向 | 一旦初始化，不能再引用其他变量 | 可以随时修改指向其他变量 |
| 内存地址 |  没有独立的内存地址，与被引用变量共享地址 |  拥有独立的内存地址，存储被指向变量的地址 |

**举例说明：**

```c++
int num = 10;
int& ref = num; // 引用
int* ptr = &num; // 指针

ref = 20; // 修改 num 的值为 20
*ptr = 30; // 修改 num 的值为 30

ptr = nullptr; // 指针可以为空指针
// int& ref2 = nullptr;  // 错误！引用不能为 nullptr
```

#### 引用的应用场景

引用常用于函数参数传递和返回值类型。

* **函数参数传递**: 使用引用传递参数，可以避免复制大型对象，提高程序效率。同时，函数内部可以直接修改参数的值，影响到函数外部的变量。

* **函数返回值类型**:  使用引用作为函数返回值类型，可以返回函数内部的局部变量，并在函数外部继续使用该变量。


### 4.4 危险！潜伏在代码中的恶魔！

指针，这柄C++的利刃，赋予了你操控内存的强大力量，但也打开了通往深渊的大门。

无数程序员在这条路上跌跌撞撞，最终迷失在代码的迷宫中。你，准备好了吗？

#### 1. 悬空指针：指向深渊的幽灵之手

释放内存，如同拆除一座桥梁，但指向它的指针却如同幽灵之手，依然伸向那片虚无。当你试图通过这个悬空指针访问内存时，就如同踏入虚空，等待你的将是程序的崩溃，或是更糟糕的情况：不可预测的行为。

```c++
int *ptr = new int;
*ptr = 10; 

delete ptr;  // 内存已释放，但指针依然存在

// 危险！ptr 现在指向一块已经失效的内存区域
*ptr = 20;  //  你的程序可能会崩溃，也可能输出不可预测的值，甚至可能覆盖其他重要数据！
```

#### 2. 野指针：无法预知的混乱之源

未经初始化的指针，就像一个没有目标的疯子，你永远不知道它会做出什么疯狂的举动。它可能指向关键数据，也可能指向系统的核心区域，任何尝试使用野指针的行为都如同引爆一颗定时炸弹，后果不堪设想。

```c++
int *ptr;   // 野指针！未被初始化，指向未知的深渊
*ptr = 10;  //  危险！你可能破坏了程序的其他数据，导致难以察觉的错误，甚至系统崩溃! 

int *ptr2 = new int;
*ptr2 = 20;
ptr = ptr2;
delete ptr2; // ptr 现在成了悬空指针，指向已经被释放的内存
*ptr = 30; // 访问了悬空指针
```

#### 3. 内存泄漏：蚕食程序的贪婪幽魂

当你申请的内存使用完毕后，却忘记释放它，就如同房间住满了客人却忘记退房，贪婪的幽魂将永远占据这片空间。内存泄漏如同慢性毒药，慢慢吞噬着系统的资源，最终导致程序运行缓慢，甚至像泄气的气球一样彻底瘫痪。

```c++
while (true) {
    int *ptr = new int;
    // ... 使用 ptr 指向的内存
    //  危险！没有释放 ptr，内存泄漏了！
} 
// 随着循环的进行，程序会消耗越来越多的内存，最终可能导致系统资源耗尽，程序崩溃。
```

#### 4.  双重释放：引爆内存的危险行径

对同一块内存区域释放两次，就如同试图拆除已经不存在的建筑。这种操作会严重破坏堆内存的结构，导致程序崩溃，如同多米诺骨牌的第一块倒下，引发连锁反应，最终导致整个程序的崩溃。

```c++
int *ptr = new int;
delete ptr;
delete ptr; // 危险！重复释放同一块内存，堆内存管理机制遭到破坏，程序崩溃！
```

#### 5.  指针算术的陷阱：迷失在内存迷宫的旅行者

指针的算术运算，赋予了你操控内存地址的能力，但稍有不慎，就会迷失在内存的迷宫中，误入歧途。越界访问，数据污染，这些致命的陷阱如同潜伏的猛兽，随时可能将你的程序撕成碎片。

```c++
int arr[5];
int *ptr = arr;
ptr += 5;   //  危险！指针越界，指向了数组边界之外的未知领域
*ptr = 10;  //  你可能修改了其他变量的值，导致难以调试的错误，甚至程序崩溃！
```

#### 6. 未对齐访问：拖慢程序的绊脚石

不同的数据类型，有不同的内存对齐要求。当你试图访问未对齐的内存地址时，就如同用错误的钥匙打开房门，轻则降低程序效率，拖慢程序的脚步，重则导致程序崩溃，让你功亏一篑。

```c++
int *ptr = (int*)malloc(sizeof(char)); // 可能导致未对齐访问，因为 malloc 返回的地址不一定按照 int 类型的对齐要求分配
*ptr = 10; //  危险！在一些体系结构上，未对齐访问会导致程序崩溃，即使不崩溃，也会降低程序的性能。
```

**与恶魔共舞，你准备好了吗？**

指针是强大的，也是危险的。每个使用指针的程序员，都如同与恶魔共舞，稍有不慎，就会陷入万劫不复的深渊。 

请记住，在指针的世界里，没有侥幸，只有谨慎和细致才能换来程序的安全和稳定！

## 第五章 - 结构体与联合体

在前面的学习中，我们已经掌握了如何使用 C++ 中的基本数据类型，比如 `int`、`float`、`char` 等。然而，在实际编程中，我们经常需要处理更复杂的数据结构，例如描述一个学生的信息（姓名、学号、成绩等），或者一个日期（年、月、日）。为了满足这些需求，C++ 提供了**结构体**、**联合体**和**枚举**这三种自定义数据类型。本章将带你深入学习这三种类型。

### 5.1 结构体

#### 5.1.1 结构体的定义和初始化

结构体是一种自定义数据类型，它允许我们将不同类型的数据组合在一起，形成一个新的数据类型。例如，我们可以定义一个名为 `Student` 的结构体来存储学生信息：

```c++
struct Student {
    string name;
    int id;
    float score;
};
```

在这个例子中，我们使用 `struct` 关键字定义了一个名为 `Student` 的结构体。结构体内部包含三个成员变量：

* `name`：存储学生的姓名，类型为 `string`。
* `id`：存储学生的学号，类型为 `int`。
* `score`：存储学生的成绩，类型为 `float`。

定义了结构体类型后，我们就可以像使用其他数据类型一样，创建结构体变量：

```c++
Student student1; // 定义一个名为 student1 的 Student 类型的变量
```

创建结构体变量后，我们可以使用 **点运算符 `.`** 来访问和修改结构体成员的值：

```c++
student1.name = "Alice";
student1.id = 12345;
student1.score = 90.5;
```

我们也可以在定义结构体变量的同时进行初始化：

```c++
Student student2 = {"Bob", 67890, 85.0};
```

#### 5.1.2 结构体数组和指针

与其他数据类型一样，我们也可以定义结构体数组和结构体指针。

**结构体数组**：

```c++
Student students[100]; // 定义一个包含 100 个 Student 元素的数组
students[0].name = "Alice";
students[0].id = 12345;
students[0].score = 90.5;
```

**结构体指针**：

```c++
Student *pStudent = &student1; // 定义一个指向 student1 的指针
cout << "Name: " << (*pStudent).name << endl; // 使用指针访问成员变量
cout << "ID: " << pStudent->id << endl; // 使用箭头运算符访问成员变量
```

**箭头运算符 `->`** 是用来访问指向*结构体变量的指针所指向的成员*。它比起使用 `(*pStudent).id` 更简单。

### 5.2 联合体

#### 5.2.1 联合体的定义和应用场景

联合体（Union）也是一种自定义数据类型，它与结构体类似，可以包含不同类型的成员。但与结构体不同的是，**联合体的所有成员共享同一块内存空间**。这意味着，**同一时间只能存储一个成员的值**，修改一个成员的值会影响其他成员的值。

定义联合体的语法与定义结构体类似，只需将 `struct` 关键字替换为 `union` 关键字：

```c++
union Data {
    int i;
    float f;
    char str[20];
};
```

在上面的例子中，我们定义了一个名为 `Data` 的联合体，它包含三个成员：`i`、`f` 和 `str`。这三个成员共享同一块内存空间，因此同一时间只能存储一个成员的值。

联合体的应用场景主要包括：

* **节省内存空间**: 当数据项之间是互斥的，即同一时间只有一个数据项有效时，可以使用联合体来节省内存空间。
* **实现数据类型的转换**:  可以通过联合体来实现不同数据类型之间的转换。

#### 5.2.2 结构体与联合体的比较

| 特性    | 结构体                | 联合体            |
|---------|---------------------|-------------------|
| 内存分配   | 为所有成员分配独立的内存空间 | 所有成员共享同一块内存空间 |
| 成员访问    | 可以同时访问所有成员     | 同一时间只能访问一个成员   |
| 内存大小   | 等于或大于所有成员大小之和 | 等于最大成员的大小         |
| 应用场景   | 存储不同类型的数据，成员之间独立 | 节省内存空间，实现数据类型转换 |


### 5.3 枚举类型

#### 5.3.1 枚举类型的定义与使用

枚举类型 (Enumeration)  是用来定义一组**具有符号名称的整型常量**的数据类型。

使用 `enum` 关键字定义枚举类型：

```c++
enum Weekday {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
};
```

在这个例子中，我们定义了一个名为 `Weekday` 的枚举类型，它包含七个枚举常量，分别代表一周的七天。默认情况下，第一个枚举常量的值为 0，后续每个枚举常量的值依次递增 1。

定义了枚举类型后，我们可以像使用其他数据类型一样，创建枚举变量：

```c++
Weekday today = Monday; 
```

枚举类型可以提高代码的可读性和可维护性，因为它使用符号名称来表示整型常量，使代码更易于理解和修改。

#### 5.3.2 枚举类型在程序中的应用

枚举类型在程序中有着广泛的应用，例如：

* **表示状态**:  可以使用枚举类型来表示程序的不同状态，例如游戏中的玩家状态（待机、移动、攻击等）。
* **表示选项**: 可以使用枚举类型来表示一组选项，例如菜单中的选项。
* **提高代码可读性**:  使用枚举类型可以使代码更易于阅读和理解，例如使用 `Weekday::Monday` 来表示星期一，比使用数字 `0` 更清晰明了。

希望通过本章的学习，你对 C++ 中的结构体、联合体和枚举类型有了更深入的了解，并能够在实际编程中灵活运用它们来解决问题。请牢记它们的特点和应用场景，并在练习中不断巩固和提高。

## 第六章 - 位运算

### 6.1 位运算基础

在深入学习位运算之前，让我们先来了解一些基本概念。

#### 位运算的基本概念

计算机内部使用二进制（0和1）来表示数据。位运算就是直接对整数在内存中的二进制位进行操作，因此位运算的效率非常高。

#### 二进制和十进制的转换

在学习位运算之前，我们需要先了解如何进行二进制和十进制之间的转换。

**十进制转换为二进制：**

不断将十进制数除以2，并记录下每次除法的余数，直到商为0为止。将得到的余数序列**逆序排列**，就是该十进制数的二进制表示。

例如，将十进制数 23 转换为二进制数：

```
23 / 2  = 11 ... 1
11 / 2  = 5  ... 1
5  / 2  = 2  ... 1
2  / 2  = 1  ... 0
1  / 2  = 0  ... 1
```

将余数逆序排列，得到 23 的二进制表示为 10111。

**二进制转换为十进制：**

从二进制数的最低位（最右边）开始，将每一位的值乘以2的对应幂次，并将所有结果相加即可。

例如，将二进制数 10111 转换为十进制数：

```
1*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = 16 + 0 + 4 + 2 + 1 = 23
```

### 6.2 常用位运算符

C++ 提供了六种位运算符，用于对整数进行位级别的操作：

#### 1. 按位与（&）

按位与运算符将两个操作数的对应位进行“与”运算。只有当两个操作数的对应位都为1时，结果才为1，否则为0。

真值表:
| A | B | A & B |
|---|---|-------|
| 0 | 0 | 0     |
| 0 | 1 | 0     |
| 1 | 0 | 0     |
| 1 | 1 | 1     |

示例：

```c++
int a = 10;     // 二进制：1010
int b = 3;      // 二进制：0011
int c = a & b;  // 二进制：0010，十进制：2
```

#### 2. 按位或（|）

按位或运算符将两个操作数的对应位进行“或”运算。只要两个操作数的对应位有一个为1，结果就为1，否则为0。

真值表:
| A | B | A \| B |
|---|---|-------|
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 1     |

示例：

```c++
int a = 10;     // 二进制：1010
int b = 3;      // 二进制：0011
int c = a | b;  // 二进制：1011，十进制：11
```

#### 3. 按位异或（^）

按位异或运算符将两个操作数的对应位进行“异或”运算。当且仅当两个操作数的对应位不同时，结果才为1，否则为0。

真值表:
| A | B | A ^ B |
|---|---|-------|
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 0     |

示例：

```c++
int a = 10;     // 二进制：1010
int b = 3;      // 二进制：0011
int c = a ^ b;  // 二进制：1001，十进制：9
```

#### 4. 按位取反（~）

按位取反运算符将操作数的每一位都取反。0 变为 1，1 变为 0。

示例：

```c++
int a = 10;     // 二进制：00001010
int b = ~a;     // 二进制：11110101，十进制：-11 (取决于编译器，最高位是符号位)
```

#### 5. 左移（<<）

左移运算符将操作数的二进制位向左移动指定的位数。高位移出后舍弃，低位补0。左移 n 位相当于将操作数乘以 2 的 n 次方。

示例：

```c++
int a = 5;        // 二进制：00000101
int b = a << 2;   // 二进制：00010100，十进制：20
```

#### 6. 右移（>>）

右移运算符将操作数的二进制位向右移动指定的位数。低位移出后舍弃，高位补符号位（正数补0，负数补1）。右移 n 位相当于将操作数除以 2 的 n 次方。

示例：

```c++
int a = 20;       // 二进制：00010100
int b = a >> 2;   // 二进制：00000101，十进制：5
```

### 6.3 位运算的应用

位运算在实际编程中有着广泛的应用，例如：

#### 1. 位掩码和位字段

位掩码通常用于检查、设置或清除一个或多个位的值。

* **检查位值:** 使用 `&` 运算符可以检查特定位的值。例如，检查变量 a 的第 2 位是否为 1:
    ```c++
    int a = 10;  // 二进制: 1010
    int mask = 1 << 1; // 创建一个只在第2位为1的掩码: 0010
    if (a & mask) {
        // 第2位为1
    }
    ```

* **设置位值:** 使用 `|` 运算符可以设置特定位的值为 1。例如，将变量 a 的第 3 位设置为 1:
    ```c++
    int a = 10;  // 二进制: 1010
    int mask = 1 << 2; // 创建一个只在第3位为1的掩码: 0100
    a = a | mask;  // a 现在是 14 (二进制: 1110)
    ```

* **清除位值:** 使用 `&` 运算符和 `~` 运算符可以清除特定位的值为 0。例如，将变量 a 的第 1 位清除为 0:
    ```c++
    int a = 10;  // 二进制: 1010
    int mask = ~(1 << 0); // 创建一个只在第1位为0的掩码: 1110
    a = a & mask;  // a 现在是 10 (二进制: 1010)
    ```

#### 2. 使用位运算进行高效计算

位运算的效率比普通运算更高，因此在一些情况下可以使用位运算来优化程序性能。

* **判断奇偶性:**  使用 & 运算符可以快速判断一个整数是奇数还是偶数。例如:
    ```c++
    if (num & 1) {
        // 奇数
    } else {
        // 偶数
    }
    ```

    代码解析：

    - 将 `num` 和 `1` 进行按位与运算。
    - `1` 的二进制表示是 `0001`。
    - 按位与运算的规则是：只有在两个对应位都是1的情况下，结果才为1，否则为0。
    - 所以 `num & 1` 这个操作实际上是在检查 `num` 的最低位（第0位）

* **交换两个数:**  使用 ^ 运算符可以不用临时变量交换两个数的值。例如:
    ```c++
    int a = 10, b = 5; // 初始化变量 a 和 b，二进制表示为：a 为1010, b 为0101

    a = a ^ b; // a 现在等于 (a ^ b)
    // 此时 a = 10 ^ 5 = 15 (二进制: 1010 ^ 0101 = 1111)

    b = a ^ b; // b 现在等于 (a ^ b), 其中 a 已经是 a ^ b 的结果
    // 此时 b = (a ^ b) ^ b = 15 ^ 5 = 10 (二进制: 1111 ^ 0101 = 1010)
    // 由于异或运算的性质，两个相同的数异或结果为0，不同的数异或结果为1，所以 b 被赋值为原来的 a 的值

    a = a ^ b; // a 现在等于 (a ^ b), 其中 a 已经是 a ^ b 的结果，而 b 是原来的 a 的值
    // 此时 a = (a ^ b) ^ b = 15 ^ 10 = 5 (二进制: 1111 ^ 1010 = 0101)
    // 同理，a 被赋值为原来的 b 的值

    // 现在 a = 5, b = 10
    ```

# 第二部分：C++进阶知识

在掌握了C++的基本语法和面向对象编程的基础知识后，我们就可以进一步探索C++语言更深层次的特性和更强大的功能。

## 第七章 栈和队列

在学习数据结构的过程中，我们会接触到各种各样的数据组织方式，栈和队列就是其中两种比较基础的线性结构。它们的区别在于元素的添加和删除顺序，掌握它们的特点和操作对于我们后续学习更加复杂的数据结构以及算法设计都大有裨益。

### 7.1 栈的基本概念

#### 7.1.1 栈的定义和特点

**栈 (Stack)** 是一种线性数据结构，它就像一个底部封闭、顶部开口的容器，只允许在顶部进行元素的添加和删除操作。栈的特点可以用 "后进先出 (Last-In, First-Out, LIFO)" 来概括，即最后被添加进栈的元素会最先被取出，类似于我们生活中堆叠的盘子，最上面的盘子总是最先被拿走。

#### 7.1.2 栈的基本操作

为了方便操作栈这种特殊的数据结构，我们定义了一些基本的操作：

- **`push(element)` (入栈):**  将一个元素 `element` 添加到栈顶，也就是将新元素放在栈顶元素的上方。
- **`pop()` (出栈):**  将栈顶元素移除并返回，就像从一摞盘子中取出最上面的一个。
- **`top()` (访问栈顶):**  返回栈顶元素，但不移除它，相当于查看最上面的盘子是什么，但不取走。
- **`isEmpty()` (判断栈是否为空):**  如果栈中没有任何元素，则返回 `true`，否则返回 `false`。
- **`size()` (获取栈的大小):**  返回栈中元素的数量，即栈中有多少个元素。

### 7.2 栈的实现

我们可以使用多种方式来实现栈这种数据结构，其中比较常见的是使用数组和链表。

#### 7.2.1 使用数组实现栈

数组是一种简单且高效的数据存储方式，我们可以利用数组来模拟栈的操作。

1. **定义栈结构:**

    ```c
    #define MAX_SIZE 100  // 定义栈的最大容量

    typedef struct {
        int data[MAX_SIZE];  // 存储栈元素的数组
        int top;             // 栈顶指针，指向栈顶元素
    } ArrayStack;
    ```

    我们使用一个结构体 `ArrayStack` 来表示栈，其中包含一个整型数组 `data` 用于存储栈元素，以及一个整型变量 `top` 指向栈顶元素的位置。

2. **初始化栈:**

    ```c
    void initStack(ArrayStack* stack) {
        stack->top = -1;  // 初始化栈顶指针，-1 表示栈为空
    }
    ```

    在使用栈之前，我们需要对其进行初始化，将 `top` 设置为 -1，表示栈为空。

3. **入栈操作:**

    ```c
    bool push(ArrayStack* stack, int element) {
        if (stack->top >= MAX_SIZE - 1) {  // 栈满
            return false; 
        } else {
            stack->top++;                // 栈顶指针上移
            stack->data[stack->top] = element;  // 将元素放入栈顶
            return true;
        }
    }
    ```

    入栈操作时，首先要判断栈是否已满，如果已满则无法入栈；否则将 `top` 指针加 1，并将新元素 `element` 放入数组 `data` 中 `top` 指针所指的位置。

4. **出栈操作:**

    ```c
    bool pop(ArrayStack* stack, int* element) {
        if (stack->top == -1) {  // 栈空
            return false;
        } else {
            *element = stack->data[stack->top];  // 取出栈顶元素
            stack->top--;                // 栈顶指针下移
            return true;
        }
    }
    ```

    出栈操作时，首先要判断栈是否为空，如果为空则无法出栈；否则将 `top` 指针所指的元素取出，并将 `top` 指针减 1。

5. **其他操作:**

    ```c
    bool isEmpty(ArrayStack* stack) {
        return stack->top == -1;
    }

    int size(ArrayStack* stack) {
        return stack->top + 1;
    }

    int topElement(ArrayStack* stack) {
        if (!isEmpty(stack)) {
            return stack->data[stack->top];
        } else {
            // 处理栈空的情况
        }
    }
    ```

    其他操作包括判断栈是否为空、获取栈的大小以及访问栈顶元素等。


通过以上步骤，我们就完成了使用数组实现栈的基本操作。需要注意的是，由于数组的长度是固定的，所以在使用数组实现栈时，需要预先设定好栈的最大容量 `MAX_SIZE`，一旦栈中元素的数量超过了最大容量，就无法再进行入栈操作，可能会导致程序出错。

#### 7.2.2 使用链表实现栈

除了数组，我们也可以使用链表来实现栈。链表是一种动态的数据结构，它不需要预先分配固定大小的内存空间，可以根据需要动态地申请和释放内存，因此使用链表实现的栈可以避免数组实现中栈容量受限的问题。

1. **定义节点结构:**

    ```c
    typedef struct Node {
        int data;           // 存储节点数据
        struct Node* next;  // 指向下一个节点的指针
    } Node;
    ```

    我们首先定义一个节点结构 `Node`，用于表示链表中的每个节点。节点包含两个成员：`data` 用于存储节点数据，`next` 指向下一个节点的指针。

2. **定义栈结构:**

    ```c
    typedef struct {
        Node* top;    // 指向栈顶节点的指针
        int size;     // 栈的大小
    } LinkedStack;
    ```

    然后我们定义栈结构 `LinkedStack`，它包含一个指向栈顶节点的指针 `top`，以及一个表示栈大小的整型变量 `size`。

3. **初始化栈:**

    ```c
    void initStack(LinkedStack* stack) {
        stack->top = NULL;  // 初始化栈顶指针为空，表示栈为空
        stack->size = 0;    // 初始化栈大小为 0
    }
    ```

    在使用栈之前，我们需要对其进行初始化，将 `top` 指针设置为 `NULL`，表示栈为空，并将 `size` 设置为 0。

4. **入栈操作:**

    ```c
    bool push(LinkedStack* stack, int element) {
        Node* newNode = (Node*)malloc(sizeof(Node));  // 分配新节点内存

        if (newNode == NULL) {  // 内存分配失败
            return false;
        }

        newNode->data = element;     // 设置新节点数据
        newNode->next = stack->top;  // 将新节点指向原栈顶节点
        stack->top = newNode;         // 更新栈顶指针
        stack->size++;               // 栈大小加 1

        return true;
    }
    ```

    入栈操作时，首先要分配一个新的节点 `newNode`，并将新元素 `element` 存入节点中。然后将 `newNode` 的 `next` 指针指向原栈顶节点，并将栈顶指针 `top` 更新为 `newNode`，最后将栈大小 `size` 加 1。

5. **出栈操作:**

    ```c
    bool pop(LinkedStack* stack, int* element) {
        if (stack->top == NULL) {  // 栈空
            return false;
        }

        Node* temp = stack->top;    // 保存栈顶节点
        *element = temp->data;      // 取出栈顶元素
        stack->top = temp->next;     // 更新栈顶指针
        free(temp);                  // 释放原栈顶节点内存
        stack->size--;               // 栈大小减 1

        return true;
    }
    ```

    出栈操作时，首先要判断栈是否为空，如果为空则无法出栈；否则将栈顶节点 `top` 保存到临时变量 `temp` 中，将 `temp` 指向的节点数据取出，并将栈顶指针 `top` 更新为 `temp` 的下一个节点，最后释放 `temp` 指向的节点内存，并将栈大小 `size` 减 1。

6. **其他操作:**

    ```c
    bool isEmpty(LinkedStack* stack) {
        return stack->top == NULL;
    }

    int size(LinkedStack* stack) {
        return stack->size;
    }

    int topElement(LinkedStack* stack) {
        if (!isEmpty(stack)) {
            return stack->top->data;
        } else {
            // 处理栈空的情况
        }
    }
    ```

    其他操作包括判断栈是否为空、获取栈的大小以及访问栈顶元素等。

使用链表实现的栈虽然在插入和删除元素时需要进行一些指针操作，略微复杂一些，但它可以根据需要动态地申请和释放内存，更加灵活，并且在频繁进行插入和删除操作时效率更高。

### 7.3 队列的基本概念

#### 7.3.1 队列的定义和特点

**队列 (Queue)** 也是一种线性数据结构，它与栈的不同之处在于队列遵循 **先进先出 (First-In, First-Out, FIFO)** 的原则。我们可以将队列想象成排队买票，先来的人先买到票，后来的人只能排在队尾等待。

队列的主要特点：

- **元素的有序性:** 队列中的元素按照添加的顺序排列，先添加的元素位于队头 (front)，后添加的元素位于队尾 (rear)。
- **操作的受限性:** 只能在队尾添加元素，在队头删除元素。

#### 7.3.2 队列的基本操作

队列通常支持以下基本操作：

- **`enqueue(element)` (入队):** 将一个元素 `element` 添加到队尾。
- **`dequeue()` (出队):**  将队头元素移除并返回。
- **`front()` (访问队头):** 返回队头元素，但不删除它。
- **`isEmpty()` (判断队列是否为空):** 如果队列为空，则返回 `true`，否则返回 `false`。
- **`size()` (获取队列的大小):** 返回队列中元素的数量。

### 7.4 队列的实现

类似于栈，队列也可以使用数组或链表来实现。

#### 7.4.1 使用数组实现队列

使用数组实现队列时，我们需要一个数组来存储队列中的元素，以及两个变量 `front` 和 `rear` 来指示队头和队尾元素的位置。

```c
#define MAX_SIZE 100  // 定义队列的最大容量

typedef struct {
    int data[MAX_SIZE];  // 存储队列元素的数组
    int front;           // 队头指针，指向队头元素
    int rear;            // 队尾指针，指向队尾元素的下一个位置
    int size;            // 队列中元素的个数
} ArrayQueue;
```

1. **初始化队列:**

    ```c
    void initQueue(ArrayQueue* queue) {
        queue->front = 0;
        queue->rear = 0;
        queue->size = 0;
    }
    ```

    初始化队列时，将 `front` 和 `rear` 都设置为 0，表示队列为空。

2. **入队操作:**

    ```c
    bool enqueue(ArrayQueue* queue, int element) {
        if (queue->size == MAX_SIZE) { // 队列满
            return false;
        } else {
            queue->data[queue->rear] = element;          // 将元素添加到队尾
            queue->rear = (queue->rear + 1) % MAX_SIZE;  // 更新队尾指针
            queue->size++;                               // 队列大小加 1
            return true;
        }
    }
    ```

    入队操作时，首先判断队列是否已满，如果已满则无法入队；否则将新元素 `element` 添加到数组 `data` 中 `rear` 指针所指的位置，并将 `rear` 指针向后移动一位。需要注意的是，当 `rear` 指针到达数组末尾时，需要将其重新指向数组的开头，形成一个循环队列。

3. **出队操作:**

    ```c
    bool dequeue(ArrayQueue* queue, int* element) {
        if (queue->size == 0) { // 队列空
            return false;
        } else {
            *element = queue->data[queue->front];         // 取出队头元素
            queue->front = (queue->front + 1) % MAX_SIZE; // 更新队头指针
            queue->size--;                                // 队列大小减 1
            return true;
        }
    }
    ```

    出队操作时，首先判断队列是否为空，如果为空则无法出队；否则将 `front` 指针所指的元素取出，并将 `front` 指针向后移动一位。同样地，当 `front` 指针到达数组末尾时，需要将其重新指向数组的开头。

4. **其他操作:**

    ```c
    bool isEmpty(ArrayQueue* queue) {
        return queue->size == 0;
    }

    int size(ArrayQueue* queue) {
        return queue->size;
    }

    int frontElement(ArrayQueue* queue) {
        if (!isEmpty(queue)) {
            return queue->data[queue->front];
        } else {
            // 处理队列空的情况
        }
    }
    ```

    其他操作包括判断队列是否为空、获取队列的大小以及访问队头元素等。


使用数组实现队列的优点是简单直观，效率较高。缺点是队列的容量是固定的，如果需要存储的元素数量超过了队列的容量，就需要进行数组扩展操作，这会降低效率。

#### 7.4.2 使用链表实现队列

与栈类似，我们也可以使用链表来实现队列，从而避免数组实现中队列容量受限的问题。

1. **定义节点结构:**

    ```c
    typedef struct Node {
        int data;           // 存储节点数据
        struct Node* next;  // 指向下一个节点的指针
    } Node;
    ```

    我们首先定义一个节点结构 `Node`，用于表示链表中的每个节点。节点包含两个成员：`data` 用于存储节点数据，`next` 指向下一个节点的指针。

2. **定义队列结构:**

    ```c
    typedef struct {
        Node* front;  // 指向队头节点的指针
        Node* rear;   // 指向队尾节点的指针
        int size;     // 队列的大小
    } LinkedQueue;
    ```

    然后我们定义队列结构 `LinkedQueue`，它包含一个指向队头节点的指针 `front`，一个指向队尾节点的指针 `rear`，以及一个表示队列大小的整型变量 `size`。

3. **初始化队列:**

    ```c
    void initQueue(LinkedQueue* queue) {
        queue->front = NULL;   // 初始化队头和队尾指针为空，表示队列为空
        queue->rear = NULL;
        queue->size = 0;       // 初始化队列大小为 0
    }
    ```

    在使用队列之前，我们需要对其进行初始化，将 `front` 和 `rear` 指针设置为 `NULL`，表示队列为空，并将 `size` 设置为 0。

4. **入队操作:**

    ```c
    bool enqueue(LinkedQueue* queue, int element) {
        Node* newNode = (Node*)malloc(sizeof(Node)); // 分配新节点内存

        if (newNode == NULL) {    // 内存分配失败
            return false; 
        }

        newNode->data = element;  // 设置新节点数据
        newNode->next = NULL;     // 新节点作为队尾节点，其 next 指针为空

        if (isEmpty(queue)) {     // 队列为空
            queue->front = newNode;       // 新节点同时作为队头节点
        } else {
            queue->rear->next = newNode;  // 将新节点链接到原队尾节点之后
        }

        queue->rear = newNode;      // 更新队尾指针
        queue->size++;              // 队列大小加 1

        return true;
    }
    ```

    入队操作时，首先要分配一个新的节点 `newNode`，并将新元素 `element` 存入节点中。然后判断队列是否为空，如果为空，则将 `newNode` 作为队头节点；否则将 `newNode` 链接到原队尾节点之后。最后更新队尾指针 `rear`，并将队列大小 `size` 加 1。

5. **出队操作:**

    ```c
    bool dequeue(LinkedQueue* queue, int* element) {
        if (isEmpty(queue)) {  // 队列为空
            return false;
        } 

        Node* temp = queue->front;   // 保存队头节点
        *element = temp->data;       // 取出队头元素
        queue->front = temp->next;   // 更新队头指针

        if (queue->front == NULL) {  // 队列只有一个元素，删除后队列为空
            queue->rear = NULL;   // 更新队尾指针为空
        }

        free(temp);                   // 释放原队头节点内存
        queue->size--;                // 队列大小减 1

        return true;
    }
    ```

    出队操作时，首先判断队列是否为空，如果为空则无法出队；否则将队头节点 `front` 保存到临时变量 `temp` 中，将 `temp` 指向的节点数据取出，并将队头指针 `front` 更新为 `temp` 的下一个节点。如果队列中只有一个元素，删除后队列为空，则需要将队尾指针 `rear` 也更新为空。最后释放 `temp` 指向的节点内存，并将队列大小 `size` 减 1。

6. **其他操作:**

    ```c
    bool isEmpty(LinkedQueue* queue) {
        return queue->front == NULL;
    }

    int size(LinkedQueue* queue) {
        return queue->size;
    }

    int frontElement(LinkedQueue* queue) {
        if (!isEmpty(queue)) {
            return queue->front->data;
        } else {
            // 处理队列空的情况
        }
    }
    ```

    其他操作包括判断队列是否为空、获取队列的大小以及访问队头元素等。


使用链表实现的队列在插入和删除元素时需要进行一些指针操作，略微复杂一些，但它可以根据需要动态地申请和释放内存，更加灵活，并且在频繁进行插入和删除操作时效率更高。

## 第八章 面向对象编程基础

在前面的章节中，我们学习了C++的基本语法和一些常用的数据结构。这些知识为我们编写结构化的程序提供了基础。然而，当程序的规模逐渐增大，复杂度不断提高时，仅仅依靠结构化编程就显得力不从心了。

面向对象编程（OOP）是一种更高级的编程范式，它将数据和操作数据的函数封装在一起，形成“对象”。这种封装的思想使得程序更易于维护、扩展和复用，同时也更贴近我们对现实世界的理解方式。

本章将介绍面向对象编程的基础知识，包括类和对象、构造函数与析构函数、类的继承以及多态性等。

### 7.1 类和对象

#### 7.1.1 类的定义与对象的创建

在面向对象编程中，类是一种用户自定义的数据类型，它将数据和操作数据的函数封装在一起，形成一个 cohesive 的单元。可以将类看作是创建对象的模板或蓝图，它定义了对象的属性（数据）和行为（函数）。

在C++中，我们使用关键字 `class` 来定义一个类。类的定义通常包含两部分：**类声明**和**类定义**。

**1. 类声明:**

类声明部分规定了类的名称以及类的成员，包括成员变量和成员函数。让我们看一个简单的例子：

```cpp
class Rectangle {
public:
    int width;
    int height;

    int getArea();
};
```

上面的代码定义了一个名为 `Rectangle` 的类。`public` 关键字被称为**访问说明符**，它规定了对类成员的访问权限，稍后我们会详细讲解。在 `public` 之后，我们声明了两个 **成员变量** `width` 和 `height`，分别代表矩形的宽度和高度。接着，我们声明了一个 **成员函数** `getArea()`，用于计算矩形的面积。需要注意的是，在类声明中，我们只需要声明成员函数的原型，即函数的返回类型、名称和参数列表，而函数的具体实现将在类定义中给出。最后，类声明以分号 `;` 结尾。

**2. 类定义:**

类定义部分提供了类成员函数的具体实现。通常情况下，我们会将类定义放在独立的头文件中（以 `.h` 或 `.hpp` 为后缀），并将该头文件包含在需要使用该类的源文件中。

```cpp
// Rectangle.h
#ifndef RECTANGLE_H
#define RECTANGLE_H

class Rectangle {
public:
    int width;
    int height;

    int getArea();
};

#endif // RECTANGLE_H
```

```cpp
// Rectangle.cpp
#include "Rectangle.h"

int Rectangle::getArea() {
    return width * height;
}
```

在上面的代码中，`Rectangle.h` 文件包含了 `Rectangle` 类的声明，而 `Rectangle.cpp` 文件包含了 `Rectangle` 类的定义。`Rectangle::getArea()` 的写法表明了 `getArea()` 函数是 `Rectangle` 类的一部分。

**3. 创建对象：**

定义了类之后，我们就可以创建该类的对象了。创建对象的方式是在类名后面加上对象名，例如：

```cpp
Rectangle rect1;
```

这行代码创建了一个名为 `rect1` 的 `Rectangle` 类型的对象。

### 7.1.2 类的成员变量和成员函数

#### 7.1.2.1 成员变量

成员变量是用来存储对象数据的变量，例如上面的 `width` 和 `height`。我们可以使用点运算符 `.` 来访问对象的成员变量，例如：

```cpp
rect1.width = 10;
rect1.height = 5;
```

#### 7.1.2.2 成员函数

成员函数是定义在类中的函数，用于操作对象的数据或实现特定的功能，例如上面的 `getArea()`。我们同样可以使用点运算符 `.` 来调用对象的成员函数，例如：

```cpp
int area = rect1.getArea();
```

#### 7.1.2.3 访问说明符

在类的定义中，我们可以使用访问说明符来控制对类成员的访问权限。C++ 提供了三种访问说明符：

* **public:**  公共成员可以在类的内部和外部访问。
* **private:** 私有成员只能在类的内部访问，不能在类的外部直接访问。
* **protected:** 保护成员类似于私有成员，但可以在派生类中访问，我们将在后续章节详细介绍。

如果未指定访问说明符，则默认情况下，类成员是私有的。

例如，在 `Rectangle` 类的定义中，`width`、`height` 和 `getArea()` 都是公共成员，这意味着我们可以在类的外部访问和修改这些成员。

```cpp
class Rectangle {
public:  // 公共成员
    int width;
    int height;

    int getArea() {
        return width * height;
    }
};
```

通常情况下，我们会将成员变量声明为私有成员，以保护数据的安全性，并提供公共的成员函数来访问和修改这些数据。

### 7.2 构造函数与析构函数

在C++中，构造函数和析构函数是两种特殊的成员函数，它们在对象的创建和销毁过程中扮演着重要的角色。

#### 7.2.1 构造函数的作用与类型

##### 7.2.1.1 构造函数的作用

构造函数是一种特殊的成员函数，它会在创建对象时自动调用，用于初始化对象的成员变量，确保对象在创建之初就处于一个合法和可用的状态。

##### 7.2.1.2 构造函数的类型

在C++中，构造函数可以分为以下几种类型：

* **默认构造函数:** 如果没有显式地定义任何构造函数，编译器会默认生成一个不带参数的构造函数，称为默认构造函数。默认构造函数会使用默认值初始化对象的成员变量。例如，对于 `int` 类型的成员变量，默认值是 0。

* **带参数构造函数:** 可以接受参数的构造函数，例如上面的 `Rectangle(int w, int h)`。带参数构造函数允许我们在创建对象时为其传递参数，从而初始化对象的成员变量。

* **拷贝构造函数:** 拷贝构造函数是一种特殊的构造函数，它接受一个同类型的对象作为参数，用于创建一个与已有对象相同的新对象。

##### 7.2.1.3 构造函数的定义

构造函数的名字必须与类名相同，并且没有返回值类型，甚至连 `void` 都不需要。例如，我们可以为 `Rectangle` 类定义一个构造函数：

```cpp
class Rectangle {
public:
    int width;
    int height;

    // 构造函数
    Rectangle(int w, int h) {
        width = w;
        height = h;
    }

    int getArea() {
        return width * height;
    }
};
```

上面的代码中，`Rectangle(int w, int h)` 就是一个构造函数，它接受两个参数，分别用于初始化 `width` 和 `height` 成员变量。

##### 7.2.1.4 构造函数的调用

创建对象时会自动调用构造函数。有了构造函数之后，我们就可以在创建对象时为其传递参数，例如：

```cpp
Rectangle rect2(8, 4);  // 创建对象时，自动调用构造函数进行初始化
```

这行代码创建了一个名为 `rect2` 的 `Rectangle` 对象，并将 `width` 初始化为 8，`height` 初始化为 4。

**需要注意的是:**

* 如果我们没有为类定义任何构造函数，编译器会自动生成一个默认构造函数。
* 如果我们定义了带参数的构造函数，编译器就不会再生成默认构造函数。
* 我们可以根据需要定义多个构造函数，只要它们的参数列表不同即可，这称为构造函数重载。

#### 7.2.2 析构函数的定义与调用

##### 7.2.2.1 析构函数的作用

当一个对象的生命周期结束时，我们需要释放它所占用的资源，例如内存空间。**析构函数**是一种特殊的成员函数，它会在对象销毁时自动调用，用于完成资源清理工作。

##### 7.2.2.2 析构函数的定义

析构函数的名字与类名相同，但在前面加了一个波浪号 `~`，并且没有返回值类型和参数。例如，我们可以为 `Rectangle` 类定义一个析构函数：

```cpp
class Rectangle {
public:
    // ... (其他成员)

    // 析构函数
    ~Rectangle() {
        // 在这里释放资源，例如打印一条信息
        std::cout << "Rectangle object destroyed!" << std::endl;
    }
};
```

##### 7.2.2.3 析构函数的调用

析构函数在对象销毁时自动调用。对象的销毁方式取决于对象的存储类型：

* **栈对象:** 存储在栈上的对象，其生命周期在超出其作用域时结束，此时会自动调用析构函数。
* **堆对象:** 存储在堆上的对象，需要使用 `delete` 运算符手动释放，`delete` 运算符会在释放内存之前自动调用析构函数。

例如：

```cpp
{
    Rectangle rect1(5, 3);  // 栈对象，在作用域结束时自动销毁
}  

Rectangle* rectPtr = new Rectangle(8, 4);  // 堆对象
// ...
delete rectPtr;  // 手动释放堆对象，并调用析构函数
```

当 `rect1` 和 `rectPtr` 对象的生命周期结束时，程序会自动调用 `~Rectangle()` 析构函数。

**需要注意的是:**

* 析构函数没有参数，也不能被重载，一个类只能有一个析构函数。
* 析构函数的调用顺序与构造函数的调用顺序相反，即先构造的后析构。

### 7.3 类的继承

在面向对象编程中，继承是一种重要的机制，它允许我们基于已有的类创建新的类。通过继承，我们可以复用已有类的代码，避免重复编写，并且可以根据需要扩展类的功能，提高代码的可维护性和可扩展性。

#### 7.3.1 继承的基本概念

继承是指在一个已有的类的基础上，创建一个新的类。这个新的类被称为**派生类**，而它所基于的类被称为**基类**。派生类会继承基类的所有成员变量和成员函数（除了构造函数和析构函数），并且可以根据需要添加新的成员变量和成员函数，或者重写基类的成员函数。

继承的关系可以用 "is-a" 来描述，例如：*汽车是一种交通工具，狗是一种动物*。

#### 7.3.2 基类与派生类的关系

基类和派生类之间是一种 "is-a" 的关系，也就是说，派生类是基类的一种特殊类型。例如，如果我们有一个 `Animal` 类作为基类，那么我们可以派生出 `Dog` 和 `Cat` 类作为派生类。

在C++中，我们使用冒号 `:` 和关键字 `public`、`protected` 或 `private` 来表示继承关系，例如：

```cpp
class 派生类名 : public 基类名 {
    // 派生类的成员
};
```

其中，`public`、`protected` 和 `private` 是三种不同的继承方式，它们决定了派生类如何访问基类的成员：

- **public 继承:**  最常用的继承方式，表示派生类可以访问基类的 `public` 和 `protected` 成员，并且基类的 `public` 成员在派生类中仍然是 `public` 的。
- **protected 继承:** 表示派生类可以访问基类的 `public` 和 `protected` 成员，但是基类的 `public` 成员在派生类中会变成 `protected` 的。
- **private 继承:** 表示派生类只能访问基类的 `public` 成员，并且基类的所有成员在派生类中都会变成 `private` 的。

**示例：**

```cpp
// 基类：动物
class Animal {
public:
    std::string name;

    void eat() {
        std::cout << name << " is eating." << std::endl;
    }
};

// 派生类：狗
class Dog : public Animal {
public:
    void bark() {
        std::cout << name << " is barking." << std::endl;
    }
};
```

在上面的代码中，`Dog` 类继承自 `Animal` 类，并使用了 `public` 继承方式。这意味着 `Dog` 类可以访问 `Animal` 类的 `public` 成员，例如 `name` 和 `eat()` 函数。

我们可以像下面这样使用 `Dog` 类：

```cpp
Dog myDog;
myDog.name = "Buddy";
myDog.eat();  // 调用基类的 eat() 函数
myDog.bark(); // 调用派生类的 bark() 函数
```

### 7.4 多态性

#### 7.4.1 虚函数和纯虚函数

**多态**是面向对象编程的另一个重要概念，它允许我们以不同的方式处理不同类型的对象。在C++中，多态是通过**虚函数**实现的。

##### 7.4.1.1 虚函数

**虚函数**是在基类中使用关键字 `virtual` 声明的函数。当派生类重写基类的虚函数时，我们可以使用指向基类的指针或引用来调用派生类的函数。

例如：

```cpp
class Animal {
public:
    virtual void makeSound() {
        std::cout << "Animal making sound." << std::endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() override { 
        std::cout << "Woof!" << std::endl;
    }
};
```

在上面的代码中，`Animal` 类中的 `makeSound()` 函数被声明为虚函数。`Dog` 类继承了 `Animal` 类，并重写了 `makeSound()` 函数。`override` 关键字是可选的，但建议使用，它可以提高代码可读性，并帮助编译器检查代码错误。

现在，我们可以使用指向基类的指针或引用来调用派生类的函数：

```cpp
Animal* animalPtr = new Dog();
animalPtr->makeSound(); // 调用 Dog 类的 makeSound() 函数

delete animalPtr;
```

##### 7.4.1.2 纯虚函数

**纯虚函数**是一种特殊的虚函数，它没有具体的实现，只是在基类中声明了一个接口，要求派生类必须提供具体的实现。

纯虚函数的声明方式是在函数声明的末尾加上 `= 0`，例如：

```cpp
class Shape {
public:
    virtual double getArea() = 0;  // 纯虚函数
};
```

包含纯虚函数的类称为**抽象类**。抽象类不能被实例化，只能作为基类被其他类继承。派生类必须提供纯虚函数的具体实现，否则派生类也将成为抽象类。

### 7.4.2 多态的实现与应用

多态（Polymorphism）源自希腊语，意为“多种形态”。在面向对象编程中，多态性允许基类指针或引用调用派生类对象的成员函数，而不需要了解派生类的具体类型。多态使得程序具有更好的灵活性和可扩展性。

#### 动态绑定机制

动态绑定机制（Dynamic Binding），也称为后期绑定（Late Binding），是在程序运行时根据指针或引用实际指向的对象类型来决定调用哪个函数。在 C++ 中，这通过虚函数表（Virtual Table，简称 vtable）实现。

每个包含虚函数的类都有一个虚函数表，表中存储了类的虚函数指针。每个对象在创建时会有一个指向虚函数表的指针，称为虚表指针（vptr）。当通过基类指针或引用调用虚函数时，程序会根据对象的虚表指针找到对应的虚函数表，从而调用正确的函数实现。

#### 应用场景

多态在以下几个场景中有广泛应用：

- **接口设计：** 通过基类定义接口，派生类实现具体功能。用户只需使用基类接口，而不必关心派生类的具体实现。
- **插件系统：** 使用多态机制，程序可以在运行时动态加载和调用插件，实现灵活的扩展。
- **框架和库设计：** 多态使得框架和库可以定义通用接口和抽象基类，用户可以通过继承和重写实现自定义功能。

通过多态性，C++ 程序能够实现更高的灵活性和可维护性，使得代码更加模块化和易于扩展。

## 第九章 模板与泛型编程

在前面的章节中，我们学习了如何使用函数和类来封装代码，提高代码的复用性和可维护性。然而，我们所写的函数和类往往只能处理特定类型的数据。例如，一个用于比较两个整数大小的函数 `max(int a, int b)` 就无法用于比较两个浮点数的大小。

为了解决这个问题，C++ 提供了模板机制，允许我们编写可以处理多种数据类型的代码，这就是**泛型编程**。泛型编程可以让我们编写更加通用、灵活和高效的代码，避免重复编写类似的代码。

本章将介绍 C++ 中的模板机制，包括函数模板和类模板，并讲解如何使用模板进行泛型编程。

### 8.1 函数模板

#### 8.1.1 函数模板的定义与使用

函数模板提供了一种通用的函数定义方式，使得同一个函数可以处理不同类型的参数，而无需为每种类型分别定义函数。

**1. 定义函数模板：**

使用关键字 `template` 后跟一个模板参数列表来定义函数模板。模板参数列表用尖括号 `<>`  括起来，其中包含一个或多个模板参数，每个模板参数都以关键字 `typename` 或 `class` 开头，后跟模板参数名。例如，我们可以定义一个用于比较两个数大小的函数模板 `max()`：

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
```

在上面的代码中，`template <typename T>` 表示这是一个函数模板，`T` 是一个模板参数，可以代表任何类型。函数的定义与普通函数类似，只是使用 `T` 来表示参数和返回值的类型。

函数模板可以有多个模板参数，用逗号分隔，例如：

```c++
template <typename T, typename U>
void func(T a, U b);
```

**2. 使用函数模板：**

使用函数模板时，编译器会根据传入的实际参数类型自动推导出模板参数的类型，并实例化出一个具体的函数。例如：

```cpp
int main() {
    int x = 10, y = 5;
    double a = 3.14, b = 2.71;

    int maxInt = max(x, y);        // 推导出 T 为 int
    double maxDouble = max(a, b);  // 推导出 T 为 double

    std::cout << "maxInt: " << maxInt << std::endl;
    std::cout << "maxDouble: " << maxDouble << std::endl;

    return 0;
}
```

在上面的代码中，我们分别使用 `int` 和 `double` 类型的变量调用了 `max()` 函数。编译器会根据传入的参数类型自动推导出 `T` 的类型，并实例化出两个版本的 `max()` 函数，一个用于比较 `int` 类型，另一个用于比较 `double` 类型。

#### 8.1.2 函数模板的实例化

函数模板本身并不是一个函数，而是一个用于生成函数的模板。当我们调用函数模板时，编译器会根据传入的实际参数类型，将函数模板实例化为一个具体的函数。这个过程被称为**模板实例化**。

**1. 自动实例化：**

如上面的例子所示，编译器可以根据函数调用时的参数类型自动推导出模板参数的类型，并自动实例化出相应的函数。

**2. 显式实例化：**

我们也可以使用空尖括号 `<>`  和具体的类型来显式地实例化函数模板。例如：

```cpp
template <typename T>
T sum(T a, T b) {
    return a + b;
}

// 显式实例化 sum<int> 函数
template int sum<int>(int a, int b); 
```

显式实例化通常用于在程序中提前实例化函数模板，以避免在多个地方使用相同的实例化而导致代码膨胀。

**需要注意的是：**

* 函数模板的定义必须放在头文件中，以便在需要使用该模板的地方包含该头文件。
* 函数模板的参数类型可以是任何类型，包括内置类型、自定义类型和指针类型等。
* 函数模板可以被重载，只要它们的模板参数列表不同即可。

### 8.2 类模板

#### 8.2.1 类模板的定义与实例化

与函数模板类似，类模板提供了一种定义类的通用方式，使得类可以处理不同类型的数据，而不需要为每种类型都定义一个单独的类。

**1. 定义类模板：**

使用关键字 `template` 后跟一个模板参数列表来定义类模板。模板参数列表用尖括号 `<>`  括起来，其中包含一个或多个模板参数，每个模板参数都以关键字 `typename` 或 `class` 开头，后跟模板参数名。例如，我们可以定义一个通用的 `Stack` 类模板，用于存储不同类型的数据：

```cpp
template <typename T>
class Stack {
private:
    T* data;           // 存储数据的数组
    int top;           // 栈顶指针
    int capacity;      // 栈的容量

public:
    Stack(int cap = 10) : capacity(cap), top(-1) {
        data = new T[capacity];
    }

    ~Stack() {
        delete[] data;
    }

    void push(const T& value);
    T pop();
    bool isEmpty() const;
    // ... 其他成员函数
};

// 成员函数定义
template <typename T>
void Stack<T>::push(const T& value) {
    if (top < capacity - 1) {
        data[++top] = value;
    } else {
        // 处理栈满的情况
    }
}

template <typename T>
T Stack<T>::pop() {
    if (!isEmpty()) {
        return data[top--];
    } else {
        // 处理栈空的情况
    }
}

template <typename T>
bool Stack<T>::isEmpty() const {
    return top == -1;
}
```

在上面的代码中，我们定义了一个名为 `Stack` 的类模板，它有一个模板参数 `T`，表示栈中存储的数据类型。在类定义中，我们使用 `T` 来表示成员变量 `data` 的类型，以及成员函数 `push()`、`pop()` 的参数和返回值类型。

**2. 实例化类模板：**

使用类模板时，需要指定具体的模板参数类型来实例化一个具体的类。例如，我们可以实例化一个存储 `int` 类型的 `Stack` 类：

```cpp
Stack<int> intStack(5);  // 实例化一个容量为 5 的 int 类型的栈
```

在上面的代码中，`Stack<int>` 表示实例化一个 `T` 为 `int` 类型的 `Stack` 类，`intStack` 是该类的对象。

#### 8.2.2 类模板的应用场景

类模板在泛型编程中有着广泛的应用，以下是一些常见的应用场景：

- **容器类：**  例如 `std::vector`、`std::list`、`std::stack` 等，用于存储不同类型的数据。
- **算法：**  例如 `std::sort`、`std::find`、`std::copy` 等，可以用于不同类型的数据。
- **迭代器：**  用于遍历容器中的元素。
- **智能指针：**  例如 `std::shared_ptr`、`std::unique_ptr` 等，用于管理动态内存。

**需要注意的是：**

* 类模板的定义通常也放在头文件中，以便在需要使用该模板的地方包含该头文件。
* 类模板的成员函数定义需要使用与类模板定义相同的模板参数列表，并在函数名之前加上类名和作用域解析运算符 `::`。
* 类模板可以继承自其他类模板或普通类，也可以被其他类模板或普通类继承。

### 8.3 STL 基础

C++ 标准模板库 (STL) 是一个强大的工具集，它提供了一组通用的数据结构和算法，可以大大简化我们的编程工作。STL 的设计理念是将数据结构和算法分离，使得它们可以独立地进行开发、测试和复用。

#### 8.3.1 常用的 STL 容器

STL 容器是用于存储和管理数据集合的对象，它们提供了各种不同的数据结构，以满足不同的需求。以下是一些常用的 STL 容器：

- **`std::vector` (动态数组):** 
    - 可以动态地增加或减少元素个数。
    - 支持随机访问元素，效率高。
    - 内存空间分配比较灵活，但可能会造成内存碎片。

    ```cpp
    #include <vector>
    std::vector<int> numbers = {1, 2, 3, 4, 5}; 
    numbers.push_back(6);   // 添加元素
    int first = numbers[0]; // 访问元素
    ```

- **`std::list` (双向链表):** 
    - 可以在任意位置高效地插入和删除元素。
    - 不支持随机访问元素，只能顺序访问。
    - 每个元素存储额外的指针，占用内存空间较多。

    ```cpp
    #include <list>
    std::list<std::string> names = {"Alice", "Bob", "Charlie"};
    names.push_front("David"); // 在头部插入元素
    ```

- **`std::deque` (双端队列):** 
    - 可以在首尾两端高效地插入和删除元素。
    - 支持随机访问元素，但效率不如 `vector`。

    ```cpp
    #include <deque>
    std::deque<double> values = {1.1, 2.2, 3.3};
    values.push_front(0.0); // 在头部插入元素
    values.pop_back(); // 删除尾部元素
    ```

- **`std::set` (集合):** 
    - 存储唯一的元素，不允许重复。
    - 元素默认按升序排列。
    - 查找元素效率高。

    ```cpp
    #include <set>
    std::set<int> uniqueNumbers = {3, 1, 4, 1, 5, 9}; // 自动排序和去重
    ```

- **`std::map` (映射):** 
    - 存储键值对，每个键对应一个值。
    - 键不允许重复，值可以重复。
    - 查找元素效率高。

    ```cpp
    #include <map>
    std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}};
    int aliceAge = ages["Alice"]; // 访问元素
    ```

#### 8.3.2 迭代器的使用

迭代器 (Iterator) 提供了一种访问容器元素的通用方法，而不需要了解容器的具体实现方式。可以将迭代器看作是指向容器元素的指针。

**1. 迭代器类型：**

- **`iterator`:**  可读可写的迭代器。
- **`const_iterator`:**  只读迭代器。
- **`reverse_iterator`:**  反向迭代器，从后往前遍历容器。
- **`const_reverse_iterator`:**  只读反向迭代器。

**2. 获取迭代器：**

- `begin()`:  返回指向容器第一个元素的迭代器。
- `end()`:  返回指向容器最后一个元素的下一个位置的迭代器 (注意不是最后一个元素)。
- `cbegin()`, `cend()`:  返回 const 迭代器。
- `rbegin()`, `rend()`:  返回反向迭代器。
- `crbegin()`, `crend()`:  返回 const 反向迭代器。

**3. 使用迭代器：**

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // 使用迭代器遍历 vector
    for (std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout << *it << " ";  // 解引用迭代器获取元素值
    }

    return 0;
}
```

注意:
* 使用迭代器时，要确保迭代器指向的元素是有效的，不要访问 end() 迭代器指向的元素。
* 当容器的结构发生变化时 (例如插入或删除元素)，迭代器可能会失效，需要重新获取迭代器。

## 第十章 多线程和多进程

在传统的程序设计中，我们编写的程序通常都是单线程的，也就是说，程序的指令都是按顺序一条一条执行的。然而，随着计算机硬件的发展，特别是多核 CPU 的普及，为了充分利用 CPU 的计算能力，提高程序的运行效率，我们需要掌握多线程和多进程编程技术。

### 10.1 多线程编程

#### 10.1.1 什么是线程

线程是操作系统能够进行运算调度的最小单位，它是进程中的一个实体，是 CPU 调度和分派的基本单位。一个进程可以包含多个线程，各个线程之间共享程序的内存空间和资源，但每个线程都有自己的独立的栈空间和程序计数器。

多线程编程的优势在于：

* **提高程序的响应速度：**  将耗时的操作放在后台线程执行，可以避免主线程阻塞，提高程序的响应速度。例如，在一个文字处理软件中，可以将文件保存操作放在后台线程执行，这样用户就可以在保存文件的同时继续编辑文档。
* **提高 CPU 的利用率：**  在多核 CPU 的环境下，多线程程序可以将计算任务分配给多个 CPU 核心同时执行，从而提高 CPU 的利用率。
* **简化程序设计：**  对于一些需要同时处理多个任务的程序，例如网络服务器，使用多线程编程可以将每个任务分配给一个独立的线程处理，简化程序的设计和实现。

#### 10.1.2 C++ 中的线程库

C++11 标准引入了线程库 `<thread>`，为多线程编程提供了支持。使用 `<thread>` 库，我们可以方便地创建和管理线程。

**1. 创建线程：**

```cpp
#include <iostream>
#include <thread>

void threadFunction() {
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    // 创建一个新线程
    std::thread myThread(threadFunction);

    // 等待线程执行完毕
    myThread.join();

    std::cout << "Main thread exiting." << std::endl;

    return 0;
}
```

在上面的代码中，我们首先定义了一个函数 `threadFunction()`，它将在新线程中执行。然后在 `main()` 函数中，我们使用 `std::thread` 类创建了一个新线程 `myThread`，并将 `threadFunction()` 函数作为参数传递给线程构造函数。`myThread.join()` 语句用于等待新线程执行完毕后，主线程再继续执行。

**2. 线程函数的参数传递：**

```cpp
#include <iostream>
#include <thread>

void threadFunction(int value) {
    std::cout << "Thread received value: " << value << std::endl;
}

int main() {
    int num = 42;

    // 创建一个新线程，并传递参数
    std::thread myThread(threadFunction, num);

    // ...
}
```

可以通过线程构造函数的参数列表将参数传递给线程函数。

**3. 线程同步：**

当多个线程同时访问共享资源时，可能会出现数据竞争的问题。为了避免数据竞争，需要使用线程同步机制来保证同一时间只有一个线程可以访问共享资源。

C++11 提供了多种线程同步机制，例如：

- **互斥量 (`std::mutex`)：**  互斥量是一种同步原语，它可以用来保护共享数据，确保同一时间只有一个线程可以访问共享数据。

```cpp
#include <iostream>
#include <thread>
#include <mutex>

// 全局变量
int shared_resource = 0;

// 互斥量
std::mutex mtx;

void increment(const std::string& thread_name) {
    for (int i = 0; i < 5; ++i) {
        mtx.lock();          // 加锁

        ++shared_resource;
        std::cout << thread_name << " incremented shared_resource to " << shared_resource << std::endl;
        
        mtx.unlock();        // 解锁
        
        // 模拟其他工作
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main() {
    // 创建两个线程
    std::thread t1(increment, "Thread 1");
    std::thread t2(increment, "Thread 2");

    // 等待两个线程完成
    t1.join();
    t2.join();

    std::cout << "Final value of shared_resource: " << shared_resource << std::endl;

    return 0;
}
```

- **条件变量 (`std::condition_variable`)：** 条件变量可以用于在线程之间发送信号，例如通知一个线程某个条件已经满足。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool ready = false; // 标志变量

void wait_for_ready() {
    std::unique_lock<std::mutex> lock(mtx); // 加锁
    std::cout << "Waiting for ready signal...\n";
    cv.wait(lock, [] { return ready; }); // 等待条件变量的通知
    std::cout << "Ready signal received!\n";
}

void set_ready() {
    std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟其他操作
    {
        std::lock_guard<std::mutex> lock(mtx); // 加锁
        ready = true; // 修改标志变量
    }
    cv.notify_one(); // 通知等待的线程
}

int main() {
    std::thread t1(wait_for_ready);
    std::thread t2(set_ready);

    t1.join();
    t2.join();

    return 0;
}
```

#### 10.1.3 线程安全的注意事项

在编写多线程程序时，需要注意以下几点：

* 避免数据竞争： 使用线程同步机制来保护共享资源，避免多个线程同时访问共享资源。
* 避免死锁： 死锁是指两个或多个线程互相等待对方释放资源，导致程序无法继续执行。为了避免死锁，需要合理地设计线程同步机制。
* 注意线程安全：  使用线程安全的函数和库，例如 C++11 提供的线程安全的容器类。



### 10.2 多进程编程

#### 10.2.1 什么是进程

进程是操作系统中资源分配的基本单位，它拥有独立的内存地址空间。一个程序在运行时至少会创建一个进程，而一个进程可以包含多个线程。与线程不同的是，进程之间拥有独立的内存空间，因此进程之间的通信更加复杂。

多进程编程的优势在于：

* **提高程序的可靠性：**  一个进程崩溃不会影响其他进程的运行。
* **充分利用多核 CPU：**  多进程程序可以将计算任务分配给多个 CPU 核心同时执行，从而提高 CPU 的利用率。

#### 10.2.2 C++ 中的多进程编程

在 C++ 中，可以使用操作系统提供的 API 来进行多进程编程。例如，在 Linux/Unix 系统中，可以使用 `fork()` 函数创建子进程。

```cpp
#include <unistd.h>
#include <sys/types.h>
#include <iostream>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 子进程
        std::cout << "Hello from child process!" << std::endl;
    } else if (pid > 0) {
        // 父进程
        std::cout << "Hello from parent process!" << std::endl;
    } else {
        // fork() 函数调用失败
        std::cerr << "Fork failed!" << std::endl;
        return 1;
    }

    return 0;
}
```

在上面的代码中，`fork()` 函数会创建一个子进程。子进程是父进程的副本，它会复制父进程的代码段、数据段、堆和栈。`fork()` 函数的返回值用于区分父进程和子进程：

* 如果返回值为 0，则表示当前进程是子进程。
* 如果返回值大于 0，则表示当前进程是父进程，返回值是子进程的进程 ID。
* 如果返回值小于 0，则表示 `fork()` 函数调用失败。

#### 10.2.3 进程间通信

进程间通信 (Inter-Process Communication, IPC) 是指不同进程之间交换数据的机制。常用的 IPC 机制包括：

* **管道 (Pipe)：**  管道是一种半双工的通信方式，它可以用于在具有亲缘关系的进程之间传递数据。
* **命名管道 (Named Pipe)：**  命名管道是一种特殊的管道，它可以在不相关的进程之间传递数据。
* **消息队列 (Message Queue)：**  消息队列是一种异步的通信方式，它允许进程以消息的形式发送和接收数据。
* **共享内存 (Shared Memory)：**  共享内存允许两个或多个进程访问同一块物理内存，从而实现高速的数据交换。

#### 10.2.4 多进程编程的注意事项

在进行多进程编程时，需要注意以下几点：

* 进程间同步：  当多个进程需要访问共享资源时，需要使用进程间同步机制来避免数据竞争。
* 进程间通信：  合理地选择 IPC 机制，根据实际需求选择效率最高、最安全的通信方式。
* 进程管理：  父进程需要负责创建、监控和清理子进程。

# 第三部分：结语
## 第十一章 结语
各位，这段C++基础课程到这里就结束了。

相信各位在学习过程中，都对编程有了更深层次的理解。从基础语法到面向对象编程，我们一同经历了从理解概念到运用实践的过程。这段旅程或许充满挑战，但也见证了各位的坚持与进步。 

编程的世界浩瀚无垠， C++ 只是其中一扇大门。更重要的是，学习编程的过程，锻炼了我们分析问题、解决问题的能力，而这种能力，在任何领域都将成为宝贵的资产。

记住，**学习编程最好的方式就是动手实践。** 永远也不要害怕犯错，每一次错误都是宝贵的学习机会。

我们有缘再会。